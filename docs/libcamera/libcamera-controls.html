<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcamera: libcamera::controls Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcamera
   &#160;<span id="projectnumber">v0.5.2+53-0e096da4</span>
   </div>
   <div id="projectbrief">Supporting cameras in Linux since 2019</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcamera.html">libcamera</a></li><li class="navelem"><a class="el" href="namespacelibcamera_1_1controls.html">controls</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">libcamera::controls Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for libcamera controls.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelibcamera_1_1controls_1_1debug"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1debug.html">debug</a></td></tr>
<tr class="memdesc:namespacelibcamera_1_1controls_1_1debug"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for debug controls. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelibcamera_1_1controls_1_1draft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1draft.html">draft</a></td></tr>
<tr class="memdesc:namespacelibcamera_1_1controls_1_1draft"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for draft controls. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a736052bee4ed070bf37c592e606edce7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a736052bee4ed070bf37c592e606edce7">AeStateEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a736052bee4ed070bf37c592e606edce7adb31217e000aff1f67a022a58aeb022c">AeStateIdle</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a736052bee4ed070bf37c592e606edce7af10bf66681dde8a1fe8caee93a30b985">AeStateSearching</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#a736052bee4ed070bf37c592e606edce7aa6e89737058289f7799aabc2c1180db9">AeStateConverged</a> = 2
 }<tr class="memdesc:a736052bee4ed070bf37c592e606edce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AeState values.  <a href="namespacelibcamera_1_1controls.html#a736052bee4ed070bf37c592e606edce7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a736052bee4ed070bf37c592e606edce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb79b8f4e3078976993af97cec6d4fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aacb79b8f4e3078976993af97cec6d4fc">AeMeteringModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#aacb79b8f4e3078976993af97cec6d4fca1883a65339da411055005d04c643d3b5">MeteringCentreWeighted</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#aacb79b8f4e3078976993af97cec6d4fcae14bf89ae3d97f4b4b1bafd8f020e8ef">MeteringSpot</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#aacb79b8f4e3078976993af97cec6d4fcaa61960c705e376114f9c7c6cc7ce87db">MeteringMatrix</a> = 2, 
<a class="el" href="namespacelibcamera_1_1controls.html#aacb79b8f4e3078976993af97cec6d4fcac81bf69da16a1b0e989fa65b58f58f30">MeteringCustom</a> = 3
 }<tr class="memdesc:aacb79b8f4e3078976993af97cec6d4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AeMeteringMode values.  <a href="namespacelibcamera_1_1controls.html#aacb79b8f4e3078976993af97cec6d4fc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aacb79b8f4e3078976993af97cec6d4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc370d05c5efc0b92f2fe285a1227426"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#acc370d05c5efc0b92f2fe285a1227426">AeConstraintModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#acc370d05c5efc0b92f2fe285a1227426aaffaec1ca246fbb986512ac383b82934">ConstraintNormal</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#acc370d05c5efc0b92f2fe285a1227426a26c02b88b44873f6f5cf04d99dffd62a">ConstraintHighlight</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#acc370d05c5efc0b92f2fe285a1227426a9a2fd95ec40dde5fba65570897a3d29d">ConstraintShadows</a> = 2, 
<a class="el" href="namespacelibcamera_1_1controls.html#acc370d05c5efc0b92f2fe285a1227426a83615b612f2349586125d57c614e6743">ConstraintCustom</a> = 3
 }<tr class="memdesc:acc370d05c5efc0b92f2fe285a1227426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AeConstraintMode values.  <a href="namespacelibcamera_1_1controls.html#acc370d05c5efc0b92f2fe285a1227426">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acc370d05c5efc0b92f2fe285a1227426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa7f5668e13d77f07b32e1379986f37"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aafa7f5668e13d77f07b32e1379986f37">AeExposureModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#aafa7f5668e13d77f07b32e1379986f37ab2119f9eb1750b1b374ca8ee903411c9">ExposureNormal</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#aafa7f5668e13d77f07b32e1379986f37aed7cca52904415bd10fc0530db1c1c48">ExposureShort</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#aafa7f5668e13d77f07b32e1379986f37aa514bf3655aba6ab11f8224b20c68b9b">ExposureLong</a> = 2, 
<a class="el" href="namespacelibcamera_1_1controls.html#aafa7f5668e13d77f07b32e1379986f37af20075f8d9c27d007c68b4cea2c46dc9">ExposureCustom</a> = 3
 }<tr class="memdesc:aafa7f5668e13d77f07b32e1379986f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AeExposureMode values.  <a href="namespacelibcamera_1_1controls.html#aafa7f5668e13d77f07b32e1379986f37">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aafa7f5668e13d77f07b32e1379986f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313d85600a65845f2f1b5a342804baf2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a313d85600a65845f2f1b5a342804baf2">ExposureTimeModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a313d85600a65845f2f1b5a342804baf2a058ab41be032e5537f04175a1ba88b54">ExposureTimeModeAuto</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a313d85600a65845f2f1b5a342804baf2af814f59de1f8a81f87e0f0a0d1cdc19d">ExposureTimeModeManual</a> = 1
 }<tr class="memdesc:a313d85600a65845f2f1b5a342804baf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported ExposureTimeMode values.  <a href="namespacelibcamera_1_1controls.html#a313d85600a65845f2f1b5a342804baf2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a313d85600a65845f2f1b5a342804baf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5391455a1ad5a48225a771094c248e77"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a5391455a1ad5a48225a771094c248e77">AnalogueGainModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a5391455a1ad5a48225a771094c248e77ac284a93dd8086b5314c032b0d3b53e41">AnalogueGainModeAuto</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a5391455a1ad5a48225a771094c248e77a4df9398e222fc283b2907b453d44c161">AnalogueGainModeManual</a> = 1
 }<tr class="memdesc:a5391455a1ad5a48225a771094c248e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AnalogueGainMode values.  <a href="namespacelibcamera_1_1controls.html#a5391455a1ad5a48225a771094c248e77">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a5391455a1ad5a48225a771094c248e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0057ec539680c4c2b48ffb51842977d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#af0057ec539680c4c2b48ffb51842977d">AeFlickerModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#af0057ec539680c4c2b48ffb51842977dad59e6651a8390a3335580bfb91daa7b4">FlickerOff</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#af0057ec539680c4c2b48ffb51842977dadf023301e5c45ed614bdc841c7d95820">FlickerManual</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#af0057ec539680c4c2b48ffb51842977da3d84ce33472523a1fbab0a5cb919e271">FlickerAuto</a> = 2
 }<tr class="memdesc:af0057ec539680c4c2b48ffb51842977d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AeFlickerMode values.  <a href="namespacelibcamera_1_1controls.html#af0057ec539680c4c2b48ffb51842977d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af0057ec539680c4c2b48ffb51842977d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcbbf6b3870d6edfd8cd00194df2ecb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecb">AwbModeEnum</a> { <br />
&#160;&#160;<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecba62fef2a2d68d34c0bebc4625283fb840">AwbAuto</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecbac16d54f93341c16a36f659fe8fbe0fcc">AwbIncandescent</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecba10f02461a07df9c309c4ad112fb47312">AwbTungsten</a> = 2, 
<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecbac09f20250445c134efe0e75857e26660">AwbFluorescent</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecbaac5efee9f6698e60823dcc00ab5d8ca4">AwbIndoor</a> = 4, 
<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecba0f7fd0bf3b7712f8cf5e6eb0e4cbab80">AwbDaylight</a> = 5, 
<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecbaca45da6c684e2f2ecab739e5117c5df0">AwbCloudy</a> = 6, 
<a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecba7966544b787350733159afcced744d1e">AwbCustom</a> = 7
<br />
 }<tr class="memdesc:a7fcbbf6b3870d6edfd8cd00194df2ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AwbMode values.  <a href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7fcbbf6b3870d6edfd8cd00194df2ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34be6a087cc3175b29d8c046bd8c10f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a34be6a087cc3175b29d8c046bd8c10f4">AfModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a34be6a087cc3175b29d8c046bd8c10f4a7f89b9faf82618ee251fed1941ac71be">AfModeManual</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a34be6a087cc3175b29d8c046bd8c10f4ac2993cfa3d15c651072dadd80c3a0014">AfModeAuto</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#a34be6a087cc3175b29d8c046bd8c10f4abba70b85fbd7f53d227b0e1d4c4dc2eb">AfModeContinuous</a> = 2
 }<tr class="memdesc:a34be6a087cc3175b29d8c046bd8c10f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfMode values.  <a href="namespacelibcamera_1_1controls.html#a34be6a087cc3175b29d8c046bd8c10f4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a34be6a087cc3175b29d8c046bd8c10f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eb0e3c5fff4cde065ae9487afb7c7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a96eb0e3c5fff4cde065ae9487afb7c7c">AfRangeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a96eb0e3c5fff4cde065ae9487afb7c7ca2e144c2445976123d85630e347cdbd9e">AfRangeNormal</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a96eb0e3c5fff4cde065ae9487afb7c7ca974441e296f7124a0ad84905dbf4db40">AfRangeMacro</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#a96eb0e3c5fff4cde065ae9487afb7c7cab941307f68600bd41fe51e2ee5d049e0">AfRangeFull</a> = 2
 }<tr class="memdesc:a96eb0e3c5fff4cde065ae9487afb7c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfRange values.  <a href="namespacelibcamera_1_1controls.html#a96eb0e3c5fff4cde065ae9487afb7c7c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a96eb0e3c5fff4cde065ae9487afb7c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ef4696d357c41da8f098f42790212d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ac5ef4696d357c41da8f098f42790212d">AfSpeedEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#ac5ef4696d357c41da8f098f42790212da1dca710ed42047a1500cbbb56fb25441">AfSpeedNormal</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#ac5ef4696d357c41da8f098f42790212daa56559e4f385097e18337d31d320232f">AfSpeedFast</a> = 1
 }<tr class="memdesc:ac5ef4696d357c41da8f098f42790212d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfSpeed values.  <a href="namespacelibcamera_1_1controls.html#ac5ef4696d357c41da8f098f42790212d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac5ef4696d357c41da8f098f42790212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f5e278c7e841d52cae5b0718fc5112"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ac1f5e278c7e841d52cae5b0718fc5112">AfMeteringEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#ac1f5e278c7e841d52cae5b0718fc5112aa8409e7e992d2b0f6feb56aa772e9489">AfMeteringAuto</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#ac1f5e278c7e841d52cae5b0718fc5112adadf8e6b97842b5aaae0bc85f33439d7">AfMeteringWindows</a> = 1
 }<tr class="memdesc:ac1f5e278c7e841d52cae5b0718fc5112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfMetering values.  <a href="namespacelibcamera_1_1controls.html#ac1f5e278c7e841d52cae5b0718fc5112">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac1f5e278c7e841d52cae5b0718fc5112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2c54ebb9dd200e458aea7632404f4a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a4e2c54ebb9dd200e458aea7632404f4a">AfTriggerEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a4e2c54ebb9dd200e458aea7632404f4aa4eafe63fd4aa2d2d2b373ed49f7bff8f">AfTriggerStart</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a4e2c54ebb9dd200e458aea7632404f4aaab71ac65071b07f1470c0e6ed5b28dda">AfTriggerCancel</a> = 1
 }<tr class="memdesc:a4e2c54ebb9dd200e458aea7632404f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfTrigger values.  <a href="namespacelibcamera_1_1controls.html#a4e2c54ebb9dd200e458aea7632404f4a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4e2c54ebb9dd200e458aea7632404f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389b5efdc0c018ddfa48586debf336ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a389b5efdc0c018ddfa48586debf336ce">AfPauseEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a389b5efdc0c018ddfa48586debf336cead46c3c20ed1d23130818768bebce116a">AfPauseImmediate</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a389b5efdc0c018ddfa48586debf336cea171616118acf646223e4b32c93a1df3c">AfPauseDeferred</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#a389b5efdc0c018ddfa48586debf336ceaacdf0c0c7c6bf0bb3ebd32225e2e121a">AfPauseResume</a> = 2
 }<tr class="memdesc:a389b5efdc0c018ddfa48586debf336ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfPause values.  <a href="namespacelibcamera_1_1controls.html#a389b5efdc0c018ddfa48586debf336ce">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a389b5efdc0c018ddfa48586debf336ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389d609fe1603637d0967331c6a4c82"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a6389d609fe1603637d0967331c6a4c82">AfStateEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#a6389d609fe1603637d0967331c6a4c82a0d09fc92f27d14189c90d00d779b4163">AfStateIdle</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a6389d609fe1603637d0967331c6a4c82a430a24f4cd7ba3a31ce7278df85f9d71">AfStateScanning</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#a6389d609fe1603637d0967331c6a4c82a7f353ea4b663c8faa7eab7d58a5a9c33">AfStateFocused</a> = 2, 
<a class="el" href="namespacelibcamera_1_1controls.html#a6389d609fe1603637d0967331c6a4c82a48701d81ec13679c835f81a2bda33900">AfStateFailed</a> = 3
 }<tr class="memdesc:a6389d609fe1603637d0967331c6a4c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfState values.  <a href="namespacelibcamera_1_1controls.html#a6389d609fe1603637d0967331c6a4c82">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6389d609fe1603637d0967331c6a4c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6eb380687d3d4f46a2d32dd30855fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aec6eb380687d3d4f46a2d32dd30855fa">AfPauseStateEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#aec6eb380687d3d4f46a2d32dd30855faa5ab3f1b3493126c5c033fae35dd049c2">AfPauseStateRunning</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#aec6eb380687d3d4f46a2d32dd30855faa258a6a176f118ee5638995668ae20fb8">AfPauseStatePausing</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#aec6eb380687d3d4f46a2d32dd30855faa700716c094b4fc72fe990c7c175ef602">AfPauseStatePaused</a> = 2
 }<tr class="memdesc:aec6eb380687d3d4f46a2d32dd30855fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported AfPauseState values.  <a href="namespacelibcamera_1_1controls.html#aec6eb380687d3d4f46a2d32dd30855fa">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aec6eb380687d3d4f46a2d32dd30855fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716de7c2d3556258c6787c02e41ee85e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85e">HdrModeEnum</a> { <br />
&#160;&#160;<a class="el" href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85ea1e04eae289d4d2c7222c4acc0a3d0624">HdrModeOff</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85ea6a69a436a4e47b21d9c981e58aea6c69">HdrModeMultiExposureUnmerged</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85ea52e7a333bcb5d1fb0e305158d512d55c">HdrModeMultiExposure</a> = 2, 
<a class="el" href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85ea9272871bd8d1866a9978fa4e425ad24c">HdrModeSingleExposure</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85ea19c922530213a17afea7e2cedbcc2877">HdrModeNight</a> = 4
<br />
 }<tr class="memdesc:a716de7c2d3556258c6787c02e41ee85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported HdrMode values.  <a href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a716de7c2d3556258c6787c02e41ee85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b385406bfae9e3f8f52632dee63c63"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ae0b385406bfae9e3f8f52632dee63c63">HdrChannelEnum</a> { <a class="el" href="namespacelibcamera_1_1controls.html#ae0b385406bfae9e3f8f52632dee63c63aadbc7d6755e8fa99635acc4c1e92d57a">HdrChannelNone</a> = 0, 
<a class="el" href="namespacelibcamera_1_1controls.html#ae0b385406bfae9e3f8f52632dee63c63a499b09f46bbbfd8b667ddbebfa34a2b1">HdrChannelShort</a> = 1, 
<a class="el" href="namespacelibcamera_1_1controls.html#ae0b385406bfae9e3f8f52632dee63c63a156cb979d82159e499b4e6b5c4a82d5e">HdrChannelMedium</a> = 2, 
<a class="el" href="namespacelibcamera_1_1controls.html#ae0b385406bfae9e3f8f52632dee63c63ac48faee52c5df4b908434ac2d7d97763">HdrChannelLong</a> = 3
 }<tr class="memdesc:ae0b385406bfae9e3f8f52632dee63c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported HdrChannel values.  <a href="namespacelibcamera_1_1controls.html#ae0b385406bfae9e3f8f52632dee63c63">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae0b385406bfae9e3f8f52632dee63c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a886fdba02620052f01c89a6686d17537"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelibcamera.html#a7d3fda0fdcda064b681b36fff326cdb7">ControlIdMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a886fdba02620052f01c89a6686d17537">controls</a></td></tr>
<tr class="memdesc:a886fdba02620052f01c89a6686d17537"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all supported libcamera controls.  <a href="#a886fdba02620052f01c89a6686d17537">More...</a><br /></td></tr>
<tr class="separator:a886fdba02620052f01c89a6686d17537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4c815586c4b8054a73425bc25ae2ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a7d4c815586c4b8054a73425bc25ae2ab">AeEnable</a></td></tr>
<tr class="memdesc:a7d4c815586c4b8054a73425bc25ae2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the AEGC algorithm. When this control is set to true, both ExposureTimeMode and AnalogueGainMode are set to auto, and if this control is set to false then both are set to manual.  <a href="#a7d4c815586c4b8054a73425bc25ae2ab">More...</a><br /></td></tr>
<tr class="separator:a7d4c815586c4b8054a73425bc25ae2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681d74a7e36ba363becd07834216d3f8"><td class="memItemLeft" align="right" valign="top"><a id="a681d74a7e36ba363becd07834216d3f8"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a681d74a7e36ba363becd07834216d3f8">AeStateValues</a></td></tr>
<tr class="memdesc:a681d74a7e36ba363becd07834216d3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AeState supported values. <br /></td></tr>
<tr class="separator:a681d74a7e36ba363becd07834216d3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9fbce1822ebff8131b9c694747ac72"><td class="memItemLeft" align="right" valign="top"><a id="a5c9fbce1822ebff8131b9c694747ac72"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a5c9fbce1822ebff8131b9c694747ac72">AeStateNameValueMap</a></td></tr>
<tr class="memdesc:a5c9fbce1822ebff8131b9c694747ac72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AeState supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a5c9fbce1822ebff8131b9c694747ac72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77dcb68a923dc60e28c475374d76221"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ac77dcb68a923dc60e28c475374d76221">AeState</a></td></tr>
<tr class="memdesc:ac77dcb68a923dc60e28c475374d76221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the AEGC algorithm state.  <a href="#ac77dcb68a923dc60e28c475374d76221">More...</a><br /></td></tr>
<tr class="separator:ac77dcb68a923dc60e28c475374d76221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc21bf9373c1d37f0428cadf0d0755c"><td class="memItemLeft" align="right" valign="top"><a id="a4fc21bf9373c1d37f0428cadf0d0755c"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a4fc21bf9373c1d37f0428cadf0d0755c">AeMeteringModeValues</a></td></tr>
<tr class="memdesc:a4fc21bf9373c1d37f0428cadf0d0755c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AeMeteringMode supported values. <br /></td></tr>
<tr class="separator:a4fc21bf9373c1d37f0428cadf0d0755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b31411749f4947343bad7ca9b9acb8"><td class="memItemLeft" align="right" valign="top"><a id="a40b31411749f4947343bad7ca9b9acb8"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a40b31411749f4947343bad7ca9b9acb8">AeMeteringModeNameValueMap</a></td></tr>
<tr class="memdesc:a40b31411749f4947343bad7ca9b9acb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AeMeteringMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a40b31411749f4947343bad7ca9b9acb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e6a00eada94491c46686ac16820a35"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a94e6a00eada94491c46686ac16820a35">AeMeteringMode</a></td></tr>
<tr class="memdesc:a94e6a00eada94491c46686ac16820a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a metering mode for the AE algorithm to use.  <a href="#a94e6a00eada94491c46686ac16820a35">More...</a><br /></td></tr>
<tr class="separator:a94e6a00eada94491c46686ac16820a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1326615d1cd62d26bfd43919befb2924"><td class="memItemLeft" align="right" valign="top"><a id="a1326615d1cd62d26bfd43919befb2924"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a1326615d1cd62d26bfd43919befb2924">AeConstraintModeValues</a></td></tr>
<tr class="memdesc:a1326615d1cd62d26bfd43919befb2924"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AeConstraintMode supported values. <br /></td></tr>
<tr class="separator:a1326615d1cd62d26bfd43919befb2924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75a8d6d95d651f06ae17282512b170b"><td class="memItemLeft" align="right" valign="top"><a id="ae75a8d6d95d651f06ae17282512b170b"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ae75a8d6d95d651f06ae17282512b170b">AeConstraintModeNameValueMap</a></td></tr>
<tr class="memdesc:ae75a8d6d95d651f06ae17282512b170b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AeConstraintMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:ae75a8d6d95d651f06ae17282512b170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4b935254e0281dce87619a5ec64030"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aff4b935254e0281dce87619a5ec64030">AeConstraintMode</a></td></tr>
<tr class="memdesc:aff4b935254e0281dce87619a5ec64030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a constraint mode for the AE algorithm to use.  <a href="#aff4b935254e0281dce87619a5ec64030">More...</a><br /></td></tr>
<tr class="separator:aff4b935254e0281dce87619a5ec64030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5767174d957f5e08af040166c5ebffc4"><td class="memItemLeft" align="right" valign="top"><a id="a5767174d957f5e08af040166c5ebffc4"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a5767174d957f5e08af040166c5ebffc4">AeExposureModeValues</a></td></tr>
<tr class="memdesc:a5767174d957f5e08af040166c5ebffc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AeExposureMode supported values. <br /></td></tr>
<tr class="separator:a5767174d957f5e08af040166c5ebffc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3bfcced3651c9d7a73bd8ba26d8bbc"><td class="memItemLeft" align="right" valign="top"><a id="ade3bfcced3651c9d7a73bd8ba26d8bbc"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ade3bfcced3651c9d7a73bd8ba26d8bbc">AeExposureModeNameValueMap</a></td></tr>
<tr class="memdesc:ade3bfcced3651c9d7a73bd8ba26d8bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AeExposureMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:ade3bfcced3651c9d7a73bd8ba26d8bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144b458b4e4261aa5f99c5fb5f4e904d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a144b458b4e4261aa5f99c5fb5f4e904d">AeExposureMode</a></td></tr>
<tr class="memdesc:a144b458b4e4261aa5f99c5fb5f4e904d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an exposure mode for the AE algorithm to use.  <a href="#a144b458b4e4261aa5f99c5fb5f4e904d">More...</a><br /></td></tr>
<tr class="separator:a144b458b4e4261aa5f99c5fb5f4e904d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8ba16db6502e4106b646019600c98d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a7b8ba16db6502e4106b646019600c98d">ExposureValue</a></td></tr>
<tr class="memdesc:a7b8ba16db6502e4106b646019600c98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an Exposure Value (EV) parameter.  <a href="#a7b8ba16db6502e4106b646019600c98d">More...</a><br /></td></tr>
<tr class="separator:a7b8ba16db6502e4106b646019600c98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1ca45653b62cd969d4d67a741076eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a4e1ca45653b62cd969d4d67a741076eb">ExposureTime</a></td></tr>
<tr class="memdesc:a4e1ca45653b62cd969d4d67a741076eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposure time for the frame applied in the sensor device.  <a href="#a4e1ca45653b62cd969d4d67a741076eb">More...</a><br /></td></tr>
<tr class="separator:a4e1ca45653b62cd969d4d67a741076eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab93883041f7270c776792c6dad91c93"><td class="memItemLeft" align="right" valign="top"><a id="aab93883041f7270c776792c6dad91c93"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aab93883041f7270c776792c6dad91c93">ExposureTimeModeValues</a></td></tr>
<tr class="memdesc:aab93883041f7270c776792c6dad91c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all ExposureTimeMode supported values. <br /></td></tr>
<tr class="separator:aab93883041f7270c776792c6dad91c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d0b03cdee91860fa000f738936d5a9"><td class="memItemLeft" align="right" valign="top"><a id="a04d0b03cdee91860fa000f738936d5a9"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a04d0b03cdee91860fa000f738936d5a9">ExposureTimeModeNameValueMap</a></td></tr>
<tr class="memdesc:a04d0b03cdee91860fa000f738936d5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all ExposureTimeMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a04d0b03cdee91860fa000f738936d5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3194f673027fc5367fc1244008c58949"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a3194f673027fc5367fc1244008c58949">ExposureTimeMode</a></td></tr>
<tr class="memdesc:a3194f673027fc5367fc1244008c58949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the source of the exposure time that is applied to the image sensor.  <a href="#a3194f673027fc5367fc1244008c58949">More...</a><br /></td></tr>
<tr class="separator:a3194f673027fc5367fc1244008c58949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34ebeaa9cbfb3f3fc6996b089ca52b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ab34ebeaa9cbfb3f3fc6996b089ca52b0">AnalogueGain</a></td></tr>
<tr class="memdesc:ab34ebeaa9cbfb3f3fc6996b089ca52b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogue gain value applied in the sensor device.  <a href="#ab34ebeaa9cbfb3f3fc6996b089ca52b0">More...</a><br /></td></tr>
<tr class="separator:ab34ebeaa9cbfb3f3fc6996b089ca52b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8918ae85e6ec0c7c9d65a7b3e298600"><td class="memItemLeft" align="right" valign="top"><a id="ae8918ae85e6ec0c7c9d65a7b3e298600"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ae8918ae85e6ec0c7c9d65a7b3e298600">AnalogueGainModeValues</a></td></tr>
<tr class="memdesc:ae8918ae85e6ec0c7c9d65a7b3e298600"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AnalogueGainMode supported values. <br /></td></tr>
<tr class="separator:ae8918ae85e6ec0c7c9d65a7b3e298600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b383197dee80ff00cf9f29c6d6676f"><td class="memItemLeft" align="right" valign="top"><a id="a92b383197dee80ff00cf9f29c6d6676f"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a92b383197dee80ff00cf9f29c6d6676f">AnalogueGainModeNameValueMap</a></td></tr>
<tr class="memdesc:a92b383197dee80ff00cf9f29c6d6676f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AnalogueGainMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a92b383197dee80ff00cf9f29c6d6676f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d5a2b6b98db922ef05fee98036c4e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a86d5a2b6b98db922ef05fee98036c4e6">AnalogueGainMode</a></td></tr>
<tr class="memdesc:a86d5a2b6b98db922ef05fee98036c4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the source of the analogue gain that is applied to the image sensor.  <a href="#a86d5a2b6b98db922ef05fee98036c4e6">More...</a><br /></td></tr>
<tr class="separator:a86d5a2b6b98db922ef05fee98036c4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2681708a81c1f52eec16a4782c6b788"><td class="memItemLeft" align="right" valign="top"><a id="ac2681708a81c1f52eec16a4782c6b788"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ac2681708a81c1f52eec16a4782c6b788">AeFlickerModeValues</a></td></tr>
<tr class="memdesc:ac2681708a81c1f52eec16a4782c6b788"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AeFlickerMode supported values. <br /></td></tr>
<tr class="separator:ac2681708a81c1f52eec16a4782c6b788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6a7a0b0322ccf3c90379854e96c593"><td class="memItemLeft" align="right" valign="top"><a id="a9a6a7a0b0322ccf3c90379854e96c593"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a9a6a7a0b0322ccf3c90379854e96c593">AeFlickerModeNameValueMap</a></td></tr>
<tr class="memdesc:a9a6a7a0b0322ccf3c90379854e96c593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AeFlickerMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a9a6a7a0b0322ccf3c90379854e96c593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2283f6a757911a29b7b4bafd5b1eb21"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#af2283f6a757911a29b7b4bafd5b1eb21">AeFlickerMode</a></td></tr>
<tr class="memdesc:af2283f6a757911a29b7b4bafd5b1eb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flicker avoidance mode for AGC/AEC.  <a href="#af2283f6a757911a29b7b4bafd5b1eb21">More...</a><br /></td></tr>
<tr class="separator:af2283f6a757911a29b7b4bafd5b1eb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bb4529055bed66332a7fe28a81ca45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#af0bb4529055bed66332a7fe28a81ca45">AeFlickerPeriod</a></td></tr>
<tr class="memdesc:af0bb4529055bed66332a7fe28a81ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual flicker period in microseconds.  <a href="#af0bb4529055bed66332a7fe28a81ca45">More...</a><br /></td></tr>
<tr class="separator:af0bb4529055bed66332a7fe28a81ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e70806b525b23bf9423889c2a56f932"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a5e70806b525b23bf9423889c2a56f932">AeFlickerDetected</a></td></tr>
<tr class="memdesc:a5e70806b525b23bf9423889c2a56f932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flicker period detected in microseconds.  <a href="#a5e70806b525b23bf9423889c2a56f932">More...</a><br /></td></tr>
<tr class="separator:a5e70806b525b23bf9423889c2a56f932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2d1f1f31581c9d80a433230753a0de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a0d2d1f1f31581c9d80a433230753a0de">Brightness</a></td></tr>
<tr class="memdesc:a0d2d1f1f31581c9d80a433230753a0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a fixed brightness parameter.  <a href="#a0d2d1f1f31581c9d80a433230753a0de">More...</a><br /></td></tr>
<tr class="separator:a0d2d1f1f31581c9d80a433230753a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f39d8c7048f1cea3af63bd2839d6b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a76f39d8c7048f1cea3af63bd2839d6b4">Contrast</a></td></tr>
<tr class="memdesc:a76f39d8c7048f1cea3af63bd2839d6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a fixed contrast parameter.  <a href="#a76f39d8c7048f1cea3af63bd2839d6b4">More...</a><br /></td></tr>
<tr class="separator:a76f39d8c7048f1cea3af63bd2839d6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930ae3cc7e47afd69580506ec6eed67b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a930ae3cc7e47afd69580506ec6eed67b">Lux</a></td></tr>
<tr class="memdesc:a930ae3cc7e47afd69580506ec6eed67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an estimate of the current illuminance level in lux.  <a href="#a930ae3cc7e47afd69580506ec6eed67b">More...</a><br /></td></tr>
<tr class="separator:a930ae3cc7e47afd69580506ec6eed67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05d11b6f22d7ed3798da7bb29a3936"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a3a05d11b6f22d7ed3798da7bb29a3936">AwbEnable</a></td></tr>
<tr class="memdesc:a3a05d11b6f22d7ed3798da7bb29a3936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the AWB.  <a href="#a3a05d11b6f22d7ed3798da7bb29a3936">More...</a><br /></td></tr>
<tr class="separator:a3a05d11b6f22d7ed3798da7bb29a3936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e06e66f35c1b86c92254c03e59535bb"><td class="memItemLeft" align="right" valign="top"><a id="a9e06e66f35c1b86c92254c03e59535bb"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a9e06e66f35c1b86c92254c03e59535bb">AwbModeValues</a></td></tr>
<tr class="memdesc:a9e06e66f35c1b86c92254c03e59535bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AwbMode supported values. <br /></td></tr>
<tr class="separator:a9e06e66f35c1b86c92254c03e59535bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545a4c73580547125f67f3bc6fa72416"><td class="memItemLeft" align="right" valign="top"><a id="a545a4c73580547125f67f3bc6fa72416"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a545a4c73580547125f67f3bc6fa72416">AwbModeNameValueMap</a></td></tr>
<tr class="memdesc:a545a4c73580547125f67f3bc6fa72416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AwbMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a545a4c73580547125f67f3bc6fa72416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8a8390defcb16e20d247df9e892eee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a1f8a8390defcb16e20d247df9e892eee">AwbMode</a></td></tr>
<tr class="memdesc:a1f8a8390defcb16e20d247df9e892eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the range of illuminants to use for the AWB algorithm.  <a href="#a1f8a8390defcb16e20d247df9e892eee">More...</a><br /></td></tr>
<tr class="separator:a1f8a8390defcb16e20d247df9e892eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8709c3405367852efae5b93af96fb6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aef8709c3405367852efae5b93af96fb6">AwbLocked</a></td></tr>
<tr class="memdesc:aef8709c3405367852efae5b93af96fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the lock status of a running AWB algorithm.  <a href="#aef8709c3405367852efae5b93af96fb6">More...</a><br /></td></tr>
<tr class="separator:aef8709c3405367852efae5b93af96fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9f01b925044ae563a6e08e930ebff7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const float, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ace9f01b925044ae563a6e08e930ebff7">ColourGains</a></td></tr>
<tr class="memdesc:ace9f01b925044ae563a6e08e930ebff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of gain values for the Red and Blue colour channels, in that order.  <a href="#ace9f01b925044ae563a6e08e930ebff7">More...</a><br /></td></tr>
<tr class="separator:ace9f01b925044ae563a6e08e930ebff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8754d2609a3a04ce5ec5880d5d4e8e5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a8754d2609a3a04ce5ec5880d5d4e8e5d">ColourTemperature</a></td></tr>
<tr class="memdesc:a8754d2609a3a04ce5ec5880d5d4e8e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ColourTemperature of the frame, in kelvin.  <a href="#a8754d2609a3a04ce5ec5880d5d4e8e5d">More...</a><br /></td></tr>
<tr class="separator:a8754d2609a3a04ce5ec5880d5d4e8e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928cbed69ee40ea268c9efcd07557521"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a928cbed69ee40ea268c9efcd07557521">Saturation</a></td></tr>
<tr class="memdesc:a928cbed69ee40ea268c9efcd07557521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a fixed saturation parameter.  <a href="#a928cbed69ee40ea268c9efcd07557521">More...</a><br /></td></tr>
<tr class="separator:a928cbed69ee40ea268c9efcd07557521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e998ced522d1c5c2de3857c86a34cbe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const int32_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a2e998ced522d1c5c2de3857c86a34cbe">SensorBlackLevels</a></td></tr>
<tr class="memdesc:a2e998ced522d1c5c2de3857c86a34cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the sensor black levels used for processing a frame.  <a href="#a2e998ced522d1c5c2de3857c86a34cbe">More...</a><br /></td></tr>
<tr class="separator:a2e998ced522d1c5c2de3857c86a34cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb754676a763e2d339474b335dfdbd8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aeb754676a763e2d339474b335dfdbd8e">Sharpness</a></td></tr>
<tr class="memdesc:aeb754676a763e2d339474b335dfdbd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intensity of the sharpening applied to the image.  <a href="#aeb754676a763e2d339474b335dfdbd8e">More...</a><br /></td></tr>
<tr class="separator:aeb754676a763e2d339474b335dfdbd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5f034588ba57aaeb4d0d79ce0735e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a3c5f034588ba57aaeb4d0d79ce0735e2">FocusFoM</a></td></tr>
<tr class="memdesc:a3c5f034588ba57aaeb4d0d79ce0735e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a Figure of Merit (FoM) to indicate how in-focus the frame is.  <a href="#a3c5f034588ba57aaeb4d0d79ce0735e2">More...</a><br /></td></tr>
<tr class="separator:a3c5f034588ba57aaeb4d0d79ce0735e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41d67783e62f20de02a621417d222aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const float, 9 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ae41d67783e62f20de02a621417d222aa">ColourCorrectionMatrix</a></td></tr>
<tr class="memdesc:ae41d67783e62f20de02a621417d222aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 3x3 matrix that converts camera RGB to sRGB within the imaging pipeline.  <a href="#ae41d67783e62f20de02a621417d222aa">More...</a><br /></td></tr>
<tr class="separator:ae41d67783e62f20de02a621417d222aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854f9e84af827f57ada03fcc12090c56"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; <a class="el" href="classlibcamera_1_1Rectangle.html">Rectangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a854f9e84af827f57ada03fcc12090c56">ScalerCrop</a></td></tr>
<tr class="memdesc:a854f9e84af827f57ada03fcc12090c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the image portion that will be scaled to form the whole of the final output image.  <a href="#a854f9e84af827f57ada03fcc12090c56">More...</a><br /></td></tr>
<tr class="separator:a854f9e84af827f57ada03fcc12090c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c8beb7cf9d9f048c5007a68922a5b1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a82c8beb7cf9d9f048c5007a68922a5b1">DigitalGain</a></td></tr>
<tr class="memdesc:a82c8beb7cf9d9f048c5007a68922a5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Digital gain value applied during the processing steps applied to the image as captured from the sensor.  <a href="#a82c8beb7cf9d9f048c5007a68922a5b1">More...</a><br /></td></tr>
<tr class="separator:a82c8beb7cf9d9f048c5007a68922a5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d99a76c7249c143beecd70917469be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a37d99a76c7249c143beecd70917469be">FrameDuration</a></td></tr>
<tr class="memdesc:a37d99a76c7249c143beecd70917469be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The instantaneous frame duration from start of frame exposure to start of next exposure, expressed in microseconds.  <a href="#a37d99a76c7249c143beecd70917469be">More...</a><br /></td></tr>
<tr class="separator:a37d99a76c7249c143beecd70917469be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3236ff99d40a3a44fcd1ad77c4458f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const int64_t, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a4f3236ff99d40a3a44fcd1ad77c4458f">FrameDurationLimits</a></td></tr>
<tr class="memdesc:a4f3236ff99d40a3a44fcd1ad77c4458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum and maximum (in that order) frame duration, expressed in microseconds.  <a href="#a4f3236ff99d40a3a44fcd1ad77c4458f">More...</a><br /></td></tr>
<tr class="separator:a4f3236ff99d40a3a44fcd1ad77c4458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b04df1f95d44b02807be3ddbd9a028"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a90b04df1f95d44b02807be3ddbd9a028">SensorTemperature</a></td></tr>
<tr class="memdesc:a90b04df1f95d44b02807be3ddbd9a028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature measure from the camera sensor in Celsius.  <a href="#a90b04df1f95d44b02807be3ddbd9a028">More...</a><br /></td></tr>
<tr class="separator:a90b04df1f95d44b02807be3ddbd9a028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0198b0e9a054328e84a4024b19742ec9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a0198b0e9a054328e84a4024b19742ec9">SensorTimestamp</a></td></tr>
<tr class="memdesc:a0198b0e9a054328e84a4024b19742ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time when the first row of the image sensor active array is exposed.  <a href="#a0198b0e9a054328e84a4024b19742ec9">More...</a><br /></td></tr>
<tr class="separator:a0198b0e9a054328e84a4024b19742ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e060ffcde7318a5389d4b05c40e4d3e"><td class="memItemLeft" align="right" valign="top"><a id="a2e060ffcde7318a5389d4b05c40e4d3e"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a2e060ffcde7318a5389d4b05c40e4d3e">AfModeValues</a></td></tr>
<tr class="memdesc:a2e060ffcde7318a5389d4b05c40e4d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfMode supported values. <br /></td></tr>
<tr class="separator:a2e060ffcde7318a5389d4b05c40e4d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ee9ad2c735294d0769211cc88cb9ac"><td class="memItemLeft" align="right" valign="top"><a id="a99ee9ad2c735294d0769211cc88cb9ac"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a99ee9ad2c735294d0769211cc88cb9ac">AfModeNameValueMap</a></td></tr>
<tr class="memdesc:a99ee9ad2c735294d0769211cc88cb9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a99ee9ad2c735294d0769211cc88cb9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4822d64036849aca4e912c50a0e608aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a4822d64036849aca4e912c50a0e608aa">AfMode</a></td></tr>
<tr class="memdesc:a4822d64036849aca4e912c50a0e608aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mode of the AF (autofocus) algorithm.  <a href="#a4822d64036849aca4e912c50a0e608aa">More...</a><br /></td></tr>
<tr class="separator:a4822d64036849aca4e912c50a0e608aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2dbec08c10a0071fff112fd03b07a9"><td class="memItemLeft" align="right" valign="top"><a id="a9a2dbec08c10a0071fff112fd03b07a9"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a9a2dbec08c10a0071fff112fd03b07a9">AfRangeValues</a></td></tr>
<tr class="memdesc:a9a2dbec08c10a0071fff112fd03b07a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfRange supported values. <br /></td></tr>
<tr class="separator:a9a2dbec08c10a0071fff112fd03b07a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a0edcbe17c5c18e13e9e8b5f798df4"><td class="memItemLeft" align="right" valign="top"><a id="ae3a0edcbe17c5c18e13e9e8b5f798df4"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ae3a0edcbe17c5c18e13e9e8b5f798df4">AfRangeNameValueMap</a></td></tr>
<tr class="memdesc:ae3a0edcbe17c5c18e13e9e8b5f798df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfRange supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:ae3a0edcbe17c5c18e13e9e8b5f798df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa4c185f9f3e22b2c4bae54d787ec9a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a3aa4c185f9f3e22b2c4bae54d787ec9a">AfRange</a></td></tr>
<tr class="memdesc:a3aa4c185f9f3e22b2c4bae54d787ec9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range of focus distances that is scanned.  <a href="#a3aa4c185f9f3e22b2c4bae54d787ec9a">More...</a><br /></td></tr>
<tr class="separator:a3aa4c185f9f3e22b2c4bae54d787ec9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b6959cca6896e0c7e499a60017ab6f"><td class="memItemLeft" align="right" valign="top"><a id="a11b6959cca6896e0c7e499a60017ab6f"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a11b6959cca6896e0c7e499a60017ab6f">AfSpeedValues</a></td></tr>
<tr class="memdesc:a11b6959cca6896e0c7e499a60017ab6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfSpeed supported values. <br /></td></tr>
<tr class="separator:a11b6959cca6896e0c7e499a60017ab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8863c3b7d7cba4522bd4fb36fbc5a1a9"><td class="memItemLeft" align="right" valign="top"><a id="a8863c3b7d7cba4522bd4fb36fbc5a1a9"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a8863c3b7d7cba4522bd4fb36fbc5a1a9">AfSpeedNameValueMap</a></td></tr>
<tr class="memdesc:a8863c3b7d7cba4522bd4fb36fbc5a1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfSpeed supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a8863c3b7d7cba4522bd4fb36fbc5a1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e57fbabf7c8844be7ee309aade7c775"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a1e57fbabf7c8844be7ee309aade7c775">AfSpeed</a></td></tr>
<tr class="memdesc:a1e57fbabf7c8844be7ee309aade7c775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the AF is to move the lens as quickly as possible or more steadily.  <a href="#a1e57fbabf7c8844be7ee309aade7c775">More...</a><br /></td></tr>
<tr class="separator:a1e57fbabf7c8844be7ee309aade7c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfc71fe3cd7b49586ef092da06d7500"><td class="memItemLeft" align="right" valign="top"><a id="a3cfc71fe3cd7b49586ef092da06d7500"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a3cfc71fe3cd7b49586ef092da06d7500">AfMeteringValues</a></td></tr>
<tr class="memdesc:a3cfc71fe3cd7b49586ef092da06d7500"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfMetering supported values. <br /></td></tr>
<tr class="separator:a3cfc71fe3cd7b49586ef092da06d7500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4772d27f5998abe376b13693a7e51265"><td class="memItemLeft" align="right" valign="top"><a id="a4772d27f5998abe376b13693a7e51265"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a4772d27f5998abe376b13693a7e51265">AfMeteringNameValueMap</a></td></tr>
<tr class="memdesc:a4772d27f5998abe376b13693a7e51265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfMetering supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a4772d27f5998abe376b13693a7e51265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae174d335b1b60832a25fa2c4d79c77a7"><td class="memItemLeft" align="right" valign="top"><a id="ae174d335b1b60832a25fa2c4d79c77a7"></a>
const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ae174d335b1b60832a25fa2c4d79c77a7">AfMetering</a></td></tr>
<tr class="memdesc:ae174d335b1b60832a25fa2c4d79c77a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parts of the image used by the AF algorithm to measure focus. <br /></td></tr>
<tr class="separator:ae174d335b1b60832a25fa2c4d79c77a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeece9e5e8fd738c5446efbdb06f93aac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const <a class="el" href="classlibcamera_1_1Rectangle.html">Rectangle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aeece9e5e8fd738c5446efbdb06f93aac">AfWindows</a></td></tr>
<tr class="memdesc:aeece9e5e8fd738c5446efbdb06f93aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The focus windows used by the AF algorithm when AfMetering is set to AfMeteringWindows.  <a href="#aeece9e5e8fd738c5446efbdb06f93aac">More...</a><br /></td></tr>
<tr class="separator:aeece9e5e8fd738c5446efbdb06f93aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9958f8b69ce8b2ecab347fcbc15699"><td class="memItemLeft" align="right" valign="top"><a id="a7d9958f8b69ce8b2ecab347fcbc15699"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a7d9958f8b69ce8b2ecab347fcbc15699">AfTriggerValues</a></td></tr>
<tr class="memdesc:a7d9958f8b69ce8b2ecab347fcbc15699"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfTrigger supported values. <br /></td></tr>
<tr class="separator:a7d9958f8b69ce8b2ecab347fcbc15699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0f8ed77c2bbc8f308ade8821ef9455"><td class="memItemLeft" align="right" valign="top"><a id="a9f0f8ed77c2bbc8f308ade8821ef9455"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a9f0f8ed77c2bbc8f308ade8821ef9455">AfTriggerNameValueMap</a></td></tr>
<tr class="memdesc:a9f0f8ed77c2bbc8f308ade8821ef9455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfTrigger supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a9f0f8ed77c2bbc8f308ade8821ef9455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78de9c118dda5b8fe763c1e4f643791"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ad78de9c118dda5b8fe763c1e4f643791">AfTrigger</a></td></tr>
<tr class="memdesc:ad78de9c118dda5b8fe763c1e4f643791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an autofocus scan.  <a href="#ad78de9c118dda5b8fe763c1e4f643791">More...</a><br /></td></tr>
<tr class="separator:ad78de9c118dda5b8fe763c1e4f643791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1255e2a42d27d93079197f1d8fd49e"><td class="memItemLeft" align="right" valign="top"><a id="a4a1255e2a42d27d93079197f1d8fd49e"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a4a1255e2a42d27d93079197f1d8fd49e">AfPauseValues</a></td></tr>
<tr class="memdesc:a4a1255e2a42d27d93079197f1d8fd49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfPause supported values. <br /></td></tr>
<tr class="separator:a4a1255e2a42d27d93079197f1d8fd49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73e8fd36cc2e126511ea1c1b1075020"><td class="memItemLeft" align="right" valign="top"><a id="ad73e8fd36cc2e126511ea1c1b1075020"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ad73e8fd36cc2e126511ea1c1b1075020">AfPauseNameValueMap</a></td></tr>
<tr class="memdesc:ad73e8fd36cc2e126511ea1c1b1075020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfPause supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:ad73e8fd36cc2e126511ea1c1b1075020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3b19553e399472896cf33c5f59095b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a3f3b19553e399472896cf33c5f59095b">AfPause</a></td></tr>
<tr class="memdesc:a3f3b19553e399472896cf33c5f59095b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause lens movements when in continuous autofocus mode.  <a href="#a3f3b19553e399472896cf33c5f59095b">More...</a><br /></td></tr>
<tr class="separator:a3f3b19553e399472896cf33c5f59095b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb623408035e51db904a0f3928a863e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#acfb623408035e51db904a0f3928a863e">LensPosition</a></td></tr>
<tr class="memdesc:acfb623408035e51db904a0f3928a863e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and report the focus lens position.  <a href="#acfb623408035e51db904a0f3928a863e">More...</a><br /></td></tr>
<tr class="separator:acfb623408035e51db904a0f3928a863e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355174bf0febced3dfd5579f3fcc9c5b"><td class="memItemLeft" align="right" valign="top"><a id="a355174bf0febced3dfd5579f3fcc9c5b"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a355174bf0febced3dfd5579f3fcc9c5b">AfStateValues</a></td></tr>
<tr class="memdesc:a355174bf0febced3dfd5579f3fcc9c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfState supported values. <br /></td></tr>
<tr class="separator:a355174bf0febced3dfd5579f3fcc9c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64e7367af8dff84a55198f449928b18"><td class="memItemLeft" align="right" valign="top"><a id="ab64e7367af8dff84a55198f449928b18"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ab64e7367af8dff84a55198f449928b18">AfStateNameValueMap</a></td></tr>
<tr class="memdesc:ab64e7367af8dff84a55198f449928b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfState supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:ab64e7367af8dff84a55198f449928b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e92d34fe6f91772c475cea4f4f648c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#af5e92d34fe6f91772c475cea4f4f648c">AfState</a></td></tr>
<tr class="memdesc:af5e92d34fe6f91772c475cea4f4f648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of the AF algorithm.  <a href="#af5e92d34fe6f91772c475cea4f4f648c">More...</a><br /></td></tr>
<tr class="separator:af5e92d34fe6f91772c475cea4f4f648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a018eb9b97b22373c4b0224746767c"><td class="memItemLeft" align="right" valign="top"><a id="ab2a018eb9b97b22373c4b0224746767c"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ab2a018eb9b97b22373c4b0224746767c">AfPauseStateValues</a></td></tr>
<tr class="memdesc:ab2a018eb9b97b22373c4b0224746767c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all AfPauseState supported values. <br /></td></tr>
<tr class="separator:ab2a018eb9b97b22373c4b0224746767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ba169b4df87424d72d89f328eef46f"><td class="memItemLeft" align="right" valign="top"><a id="ad0ba169b4df87424d72d89f328eef46f"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#ad0ba169b4df87424d72d89f328eef46f">AfPauseStateNameValueMap</a></td></tr>
<tr class="memdesc:ad0ba169b4df87424d72d89f328eef46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all AfPauseState supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:ad0ba169b4df87424d72d89f328eef46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f3467ef96f2044ef9e2065847ea2b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a73f3467ef96f2044ef9e2065847ea2b5">AfPauseState</a></td></tr>
<tr class="memdesc:a73f3467ef96f2044ef9e2065847ea2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the autofocus is currently running, paused or pausing.  <a href="#a73f3467ef96f2044ef9e2065847ea2b5">More...</a><br /></td></tr>
<tr class="separator:a73f3467ef96f2044ef9e2065847ea2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6fa82ff5197d16bf24206bd4a601b8"><td class="memItemLeft" align="right" valign="top"><a id="a9d6fa82ff5197d16bf24206bd4a601b8"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a9d6fa82ff5197d16bf24206bd4a601b8">HdrModeValues</a></td></tr>
<tr class="memdesc:a9d6fa82ff5197d16bf24206bd4a601b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all HdrMode supported values. <br /></td></tr>
<tr class="separator:a9d6fa82ff5197d16bf24206bd4a601b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961f167be30837e5236218a613b936e5"><td class="memItemLeft" align="right" valign="top"><a id="a961f167be30837e5236218a613b936e5"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a961f167be30837e5236218a613b936e5">HdrModeNameValueMap</a></td></tr>
<tr class="memdesc:a961f167be30837e5236218a613b936e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all HdrMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a961f167be30837e5236218a613b936e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db8fe54958db67aaef37c0d7e65444d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a6db8fe54958db67aaef37c0d7e65444d">HdrMode</a></td></tr>
<tr class="memdesc:a6db8fe54958db67aaef37c0d7e65444d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode to be used for High Dynamic Range (HDR) imaging.  <a href="#a6db8fe54958db67aaef37c0d7e65444d">More...</a><br /></td></tr>
<tr class="separator:a6db8fe54958db67aaef37c0d7e65444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5632401a1cdc17220f3def1d095040a9"><td class="memItemLeft" align="right" valign="top"><a id="a5632401a1cdc17220f3def1d095040a9"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a5632401a1cdc17220f3def1d095040a9">HdrChannelValues</a></td></tr>
<tr class="memdesc:a5632401a1cdc17220f3def1d095040a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all HdrChannel supported values. <br /></td></tr>
<tr class="separator:a5632401a1cdc17220f3def1d095040a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099cf0a5def9ffdd7883269976c1daf7"><td class="memItemLeft" align="right" valign="top"><a id="a099cf0a5def9ffdd7883269976c1daf7"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a099cf0a5def9ffdd7883269976c1daf7">HdrChannelNameValueMap</a></td></tr>
<tr class="memdesc:a099cf0a5def9ffdd7883269976c1daf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all HdrChannel supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:a099cf0a5def9ffdd7883269976c1daf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9834a875f8dd3928fb9ea76eaa3780a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a9834a875f8dd3928fb9ea76eaa3780a1">HdrChannel</a></td></tr>
<tr class="memdesc:a9834a875f8dd3928fb9ea76eaa3780a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HDR channel used to capture the frame.  <a href="#a9834a875f8dd3928fb9ea76eaa3780a1">More...</a><br /></td></tr>
<tr class="separator:a9834a875f8dd3928fb9ea76eaa3780a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bc162c4f3818ea673b541ef7a69118"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a75bc162c4f3818ea673b541ef7a69118">Gamma</a></td></tr>
<tr class="memdesc:a75bc162c4f3818ea673b541ef7a69118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a fixed gamma value.  <a href="#a75bc162c4f3818ea673b541ef7a69118">More...</a><br /></td></tr>
<tr class="separator:a75bc162c4f3818ea673b541ef7a69118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5d3b6463ed05792f6b0a64b0fa5087"><td class="memItemLeft" align="right" valign="top"><a id="a8f5d3b6463ed05792f6b0a64b0fa5087"></a>
const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#a8f5d3b6463ed05792f6b0a64b0fa5087">DebugMetadataEnable</a></td></tr>
<tr class="memdesc:a8f5d3b6463ed05792f6b0a64b0fa5087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the debug metadata. <br /></td></tr>
<tr class="separator:a8f5d3b6463ed05792f6b0a64b0fa5087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4db106ea27d988584ca1f730207602f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls.html#aa4db106ea27d988584ca1f730207602f">FrameWallClock</a></td></tr>
<tr class="memdesc:aa4db106ea27d988584ca1f730207602f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This timestamp corresponds to the same moment in time as the SensorTimestamp, but is represented as a wall clock time as measured by the CLOCK_REALTIME clock. Like SensorTimestamp, the timestamp value is expressed in nanoseconds.  <a href="#aa4db106ea27d988584ca1f730207602f">More...</a><br /></td></tr>
<tr class="separator:aa4db106ea27d988584ca1f730207602f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for libcamera controls. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acc370d05c5efc0b92f2fe285a1227426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc370d05c5efc0b92f2fe285a1227426">&#9670;&nbsp;</a></span>AeConstraintModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#acc370d05c5efc0b92f2fe285a1227426">libcamera::controls::AeConstraintModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AeConstraintMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acc370d05c5efc0b92f2fe285a1227426aaffaec1ca246fbb986512ac383b82934"></a>ConstraintNormal&#160;</td><td class="fielddoc"><p>Default constraint mode. </p>
<p>This mode aims to balance the exposure of different parts of the image so as to reach a reasonable average level. However, highlights in the image may appear over-exposed and lowlights may appear under-exposed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acc370d05c5efc0b92f2fe285a1227426a26c02b88b44873f6f5cf04d99dffd62a"></a>ConstraintHighlight&#160;</td><td class="fielddoc"><p>Highlight constraint mode. </p>
<p>This mode adjusts the exposure levels in order to try and avoid over-exposing the brightest parts (highlights) of an image. Other non-highlight parts of the image may appear under-exposed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acc370d05c5efc0b92f2fe285a1227426a9a2fd95ec40dde5fba65570897a3d29d"></a>ConstraintShadows&#160;</td><td class="fielddoc"><p>Shadows constraint mode. </p>
<p>This mode adjusts the exposure levels in order to try and avoid under-exposing the dark parts (shadows) of an image. Other normally exposed parts of the image may appear over-exposed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acc370d05c5efc0b92f2fe285a1227426a83615b612f2349586125d57c614e6743"></a>ConstraintCustom&#160;</td><td class="fielddoc"><p>Custom constraint mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="aafa7f5668e13d77f07b32e1379986f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa7f5668e13d77f07b32e1379986f37">&#9670;&nbsp;</a></span>AeExposureModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#aafa7f5668e13d77f07b32e1379986f37">libcamera::controls::AeExposureModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AeExposureMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aafa7f5668e13d77f07b32e1379986f37ab2119f9eb1750b1b374ca8ee903411c9"></a>ExposureNormal&#160;</td><td class="fielddoc"><p>Default exposure mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="aafa7f5668e13d77f07b32e1379986f37aed7cca52904415bd10fc0530db1c1c48"></a>ExposureShort&#160;</td><td class="fielddoc"><p>Exposure mode allowing only short exposure times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aafa7f5668e13d77f07b32e1379986f37aa514bf3655aba6ab11f8224b20c68b9b"></a>ExposureLong&#160;</td><td class="fielddoc"><p>Exposure mode allowing long exposure times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aafa7f5668e13d77f07b32e1379986f37af20075f8d9c27d007c68b4cea2c46dc9"></a>ExposureCustom&#160;</td><td class="fielddoc"><p>Custom exposure mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="af0057ec539680c4c2b48ffb51842977d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0057ec539680c4c2b48ffb51842977d">&#9670;&nbsp;</a></span>AeFlickerModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#af0057ec539680c4c2b48ffb51842977d">libcamera::controls::AeFlickerModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AeFlickerMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af0057ec539680c4c2b48ffb51842977dad59e6651a8390a3335580bfb91daa7b4"></a>FlickerOff&#160;</td><td class="fielddoc"><p>No flicker avoidance is performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="af0057ec539680c4c2b48ffb51842977dadf023301e5c45ed614bdc841c7d95820"></a>FlickerManual&#160;</td><td class="fielddoc"><p>Manual flicker avoidance. </p>
<p>Suppress flicker effects caused by lighting running with a period specified by the AeFlickerPeriod control. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#af0bb4529055bed66332a7fe28a81ca45" title="Manual flicker period in microseconds. ">AeFlickerPeriod</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="af0057ec539680c4c2b48ffb51842977da3d84ce33472523a1fbab0a5cb919e271"></a>FlickerAuto&#160;</td><td class="fielddoc"><p>Automatic flicker period detection and avoidance. </p>
<p>The system will automatically determine the most likely value of flicker period, and avoid flicker of this frequency. Once flicker is being corrected, it is implementation dependent whether the system is still able to detect a change in the flicker period. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a5e70806b525b23bf9423889c2a56f932" title="Flicker period detected in microseconds. ">AeFlickerDetected</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="aacb79b8f4e3078976993af97cec6d4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb79b8f4e3078976993af97cec6d4fc">&#9670;&nbsp;</a></span>AeMeteringModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#aacb79b8f4e3078976993af97cec6d4fc">libcamera::controls::AeMeteringModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AeMeteringMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aacb79b8f4e3078976993af97cec6d4fca1883a65339da411055005d04c643d3b5"></a>MeteringCentreWeighted&#160;</td><td class="fielddoc"><p>Centre-weighted metering mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="aacb79b8f4e3078976993af97cec6d4fcae14bf89ae3d97f4b4b1bafd8f020e8ef"></a>MeteringSpot&#160;</td><td class="fielddoc"><p>Spot metering mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="aacb79b8f4e3078976993af97cec6d4fcaa61960c705e376114f9c7c6cc7ce87db"></a>MeteringMatrix&#160;</td><td class="fielddoc"><p>Matrix metering mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="aacb79b8f4e3078976993af97cec6d4fcac81bf69da16a1b0e989fa65b58f58f30"></a>MeteringCustom&#160;</td><td class="fielddoc"><p>Custom metering mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="a736052bee4ed070bf37c592e606edce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736052bee4ed070bf37c592e606edce7">&#9670;&nbsp;</a></span>AeStateEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a736052bee4ed070bf37c592e606edce7">libcamera::controls::AeStateEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AeState values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a736052bee4ed070bf37c592e606edce7adb31217e000aff1f67a022a58aeb022c"></a>AeStateIdle&#160;</td><td class="fielddoc"><p>The AEGC algorithm is inactive. </p>
<p>This state is returned when both AnalogueGainMode and ExposureTimeMode are set to Manual and the algorithm is not actively computing any value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a736052bee4ed070bf37c592e606edce7af10bf66681dde8a1fe8caee93a30b985"></a>AeStateSearching&#160;</td><td class="fielddoc"><p>The AEGC algorithm is actively computing new values, for either the exposure time or the analogue gain, but has not converged to a stable result yet. </p>
<p>This state is returned if at least one of AnalogueGainMode or ExposureTimeMode is auto and the algorithm hasn't converged yet.</p>
<p>The AEGC algorithm converges once stable values are computed for all of the controls set to be computed in Auto mode. Once the algorithm converges the state is moved to AeStateConverged. </p>
</td></tr>
<tr><td class="fieldname"><a id="a736052bee4ed070bf37c592e606edce7aa6e89737058289f7799aabc2c1180db9"></a>AeStateConverged&#160;</td><td class="fielddoc"><p>The AEGC algorithm has converged. </p>
<p>This state is returned if at least one of AnalogueGainMode or ExposureTimeMode is Auto, and the AEGC algorithm has converged to a stable value.</p>
<p>If the measurements move too far away from the convergence point then the AEGC algorithm might start adjusting again, in which case the state is moved to AeStateSearching. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac1f5e278c7e841d52cae5b0718fc5112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f5e278c7e841d52cae5b0718fc5112">&#9670;&nbsp;</a></span>AfMeteringEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#ac1f5e278c7e841d52cae5b0718fc5112">libcamera::controls::AfMeteringEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfMetering values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac1f5e278c7e841d52cae5b0718fc5112aa8409e7e992d2b0f6feb56aa772e9489"></a>AfMeteringAuto&#160;</td><td class="fielddoc"><p>Let the AF algorithm decide for itself where it will measure focus. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac1f5e278c7e841d52cae5b0718fc5112adadf8e6b97842b5aaae0bc85f33439d7"></a>AfMeteringWindows&#160;</td><td class="fielddoc"><p>Use the rectangles defined by the AfWindows control to measure focus. </p>
<p>If no windows are specified the behaviour is platform dependent. </p>
</td></tr>
</table>

</div>
</div>
<a id="a34be6a087cc3175b29d8c046bd8c10f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34be6a087cc3175b29d8c046bd8c10f4">&#9670;&nbsp;</a></span>AfModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a34be6a087cc3175b29d8c046bd8c10f4">libcamera::controls::AfModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34be6a087cc3175b29d8c046bd8c10f4a7f89b9faf82618ee251fed1941ac71be"></a>AfModeManual&#160;</td><td class="fielddoc"><p>The AF algorithm is in manual mode. </p>
<p>In this mode it will never perform any action nor move the lens of its own accord, but an application can specify the desired lens position using the LensPosition control. The AfState will always report AfStateIdle.</p>
<p>If the camera is started in AfModeManual, it will move the focus lens to the position specified by the LensPosition control.</p>
<p>This mode is the recommended default value for the AfMode control. External cameras (as reported by the Location property set to CameraLocationExternal) may use a different default value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34be6a087cc3175b29d8c046bd8c10f4ac2993cfa3d15c651072dadd80c3a0014"></a>AfModeAuto&#160;</td><td class="fielddoc"><p>The AF algorithm is in auto mode. </p>
<p>In this mode the algorithm will never move the lens or change state unless the AfTrigger control is used. The AfTrigger control can be used to initiate a focus scan, the results of which will be reported by AfState.</p>
<p>If the autofocus algorithm is moved from AfModeAuto to another mode while a scan is in progress, the scan is cancelled immediately, without waiting for the scan to finish.</p>
<p>When first entering this mode the AfState will report AfStateIdle. When a trigger control is sent, AfState will report AfStateScanning for a period before spontaneously changing to AfStateFocused or AfStateFailed, depending on the outcome of the scan. It will remain in this state until another scan is initiated by the AfTrigger control. If a scan is cancelled (without changing to another mode), AfState will return to AfStateIdle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34be6a087cc3175b29d8c046bd8c10f4abba70b85fbd7f53d227b0e1d4c4dc2eb"></a>AfModeContinuous&#160;</td><td class="fielddoc"><p>The AF algorithm is in continuous mode. </p>
<p>In this mode the lens can re-start a scan spontaneously at any moment, without any user intervention. The AfState still reports whether the algorithm is currently scanning or not, though the application has no ability to initiate or cancel scans, nor to move the lens for itself.</p>
<p>However, applications can pause the AF algorithm from continuously scanning by using the AfPause control. This allows video or still images to be captured whilst guaranteeing that the focus is fixed.</p>
<p>When set to AfModeContinuous, the system will immediately initiate a scan so AfState will report AfStateScanning, and will settle on one of AfStateFocused or AfStateFailed, depending on the scan result. </p>
</td></tr>
</table>

</div>
</div>
<a id="a389b5efdc0c018ddfa48586debf336ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389b5efdc0c018ddfa48586debf336ce">&#9670;&nbsp;</a></span>AfPauseEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a389b5efdc0c018ddfa48586debf336ce">libcamera::controls::AfPauseEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfPause values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a389b5efdc0c018ddfa48586debf336cead46c3c20ed1d23130818768bebce116a"></a>AfPauseImmediate&#160;</td><td class="fielddoc"><p>Pause the continuous autofocus algorithm immediately. </p>
<p>The autofocus algorithm is paused whether or not any kind of scan is underway. AfPauseState will subsequently report AfPauseStatePaused. AfState may report any of AfStateScanning, AfStateFocused or AfStateFailed, depending on the algorithm's state when it received this control. </p>
</td></tr>
<tr><td class="fieldname"><a id="a389b5efdc0c018ddfa48586debf336cea171616118acf646223e4b32c93a1df3c"></a>AfPauseDeferred&#160;</td><td class="fielddoc"><p>Pause the continuous autofocus algorithm at the end of the scan. </p>
<p>This is similar to AfPauseImmediate, and if the AfState is currently reporting AfStateFocused or AfStateFailed it will remain in that state and AfPauseState will report AfPauseStatePaused.</p>
<p>However, if the algorithm is scanning (AfStateScanning), AfPauseState will report AfPauseStatePausing until the scan is finished, at which point AfState will report one of AfStateFocused or AfStateFailed, and AfPauseState will change to AfPauseStatePaused. </p>
</td></tr>
<tr><td class="fieldname"><a id="a389b5efdc0c018ddfa48586debf336ceaacdf0c0c7c6bf0bb3ebd32225e2e121a"></a>AfPauseResume&#160;</td><td class="fielddoc"><p>Resume continuous autofocus operation. </p>
<p>The algorithm starts again from exactly where it left off, and AfPauseState will report AfPauseStateRunning. </p>
</td></tr>
</table>

</div>
</div>
<a id="aec6eb380687d3d4f46a2d32dd30855fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6eb380687d3d4f46a2d32dd30855fa">&#9670;&nbsp;</a></span>AfPauseStateEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#aec6eb380687d3d4f46a2d32dd30855fa">libcamera::controls::AfPauseStateEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfPauseState values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aec6eb380687d3d4f46a2d32dd30855faa5ab3f1b3493126c5c033fae35dd049c2"></a>AfPauseStateRunning&#160;</td><td class="fielddoc"><p>Continuous AF is running and the algorithm may restart a scan spontaneously. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec6eb380687d3d4f46a2d32dd30855faa258a6a176f118ee5638995668ae20fb8"></a>AfPauseStatePausing&#160;</td><td class="fielddoc"><p>Continuous AF has been sent an AfPauseDeferred control, and will pause as soon as any in-progress scan completes. </p>
<p>When the scan completes, the AfPauseState control will report AfPauseStatePaused. No new scans will be start spontaneously until the AfPauseResume control is sent. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec6eb380687d3d4f46a2d32dd30855faa700716c094b4fc72fe990c7c175ef602"></a>AfPauseStatePaused&#160;</td><td class="fielddoc"><p>Continuous AF is paused. </p>
<p>No further state changes or lens movements will occur until the AfPauseResume control is sent. </p>
</td></tr>
</table>

</div>
</div>
<a id="a96eb0e3c5fff4cde065ae9487afb7c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96eb0e3c5fff4cde065ae9487afb7c7c">&#9670;&nbsp;</a></span>AfRangeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a96eb0e3c5fff4cde065ae9487afb7c7c">libcamera::controls::AfRangeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfRange values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a96eb0e3c5fff4cde065ae9487afb7c7ca2e144c2445976123d85630e347cdbd9e"></a>AfRangeNormal&#160;</td><td class="fielddoc"><p>A wide range of focus distances is scanned. </p>
<p>Scanned distances cover all the way from infinity down to close distances, though depending on the implementation, possibly not including the very closest macro positions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a96eb0e3c5fff4cde065ae9487afb7c7ca974441e296f7124a0ad84905dbf4db40"></a>AfRangeMacro&#160;</td><td class="fielddoc"><p>Only close distances are scanned. </p>
</td></tr>
<tr><td class="fieldname"><a id="a96eb0e3c5fff4cde065ae9487afb7c7cab941307f68600bd41fe51e2ee5d049e0"></a>AfRangeFull&#160;</td><td class="fielddoc"><p>The full range of focus distances is scanned. </p>
<p>This range is similar to AfRangeNormal but includes the very closest macro positions. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac5ef4696d357c41da8f098f42790212d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ef4696d357c41da8f098f42790212d">&#9670;&nbsp;</a></span>AfSpeedEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#ac5ef4696d357c41da8f098f42790212d">libcamera::controls::AfSpeedEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfSpeed values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac5ef4696d357c41da8f098f42790212da1dca710ed42047a1500cbbb56fb25441"></a>AfSpeedNormal&#160;</td><td class="fielddoc"><p>Move the lens at its usual speed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5ef4696d357c41da8f098f42790212daa56559e4f385097e18337d31d320232f"></a>AfSpeedFast&#160;</td><td class="fielddoc"><p>Move the lens more quickly. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6389d609fe1603637d0967331c6a4c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6389d609fe1603637d0967331c6a4c82">&#9670;&nbsp;</a></span>AfStateEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a6389d609fe1603637d0967331c6a4c82">libcamera::controls::AfStateEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfState values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6389d609fe1603637d0967331c6a4c82a0d09fc92f27d14189c90d00d779b4163"></a>AfStateIdle&#160;</td><td class="fielddoc"><p>The AF algorithm is in manual mode (AfModeManual) or in auto mode (AfModeAuto) and a scan has not yet been triggered, or an in-progress scan was cancelled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6389d609fe1603637d0967331c6a4c82a430a24f4cd7ba3a31ce7278df85f9d71"></a>AfStateScanning&#160;</td><td class="fielddoc"><p>The AF algorithm is in auto mode (AfModeAuto), and a scan has been started using the AfTrigger control. </p>
<p>The scan can be cancelled by sending AfTriggerCancel at which point the algorithm will either move back to AfStateIdle or, if the scan actually completes before the cancel request is processed, to one of AfStateFocused or AfStateFailed.</p>
<p>Alternatively the AF algorithm could be in continuous mode (AfModeContinuous) at which point it may enter this state spontaneously whenever it determines that a rescan is needed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6389d609fe1603637d0967331c6a4c82a7f353ea4b663c8faa7eab7d58a5a9c33"></a>AfStateFocused&#160;</td><td class="fielddoc"><p>The AF algorithm is in auto (AfModeAuto) or continuous (AfModeContinuous) mode and a scan has completed with the result that the algorithm believes the image is now in focus. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6389d609fe1603637d0967331c6a4c82a48701d81ec13679c835f81a2bda33900"></a>AfStateFailed&#160;</td><td class="fielddoc"><p>The AF algorithm is in auto (AfModeAuto) or continuous (AfModeContinuous) mode and a scan has completed with the result that the algorithm did not find a good focus position. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4e2c54ebb9dd200e458aea7632404f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2c54ebb9dd200e458aea7632404f4a">&#9670;&nbsp;</a></span>AfTriggerEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a4e2c54ebb9dd200e458aea7632404f4a">libcamera::controls::AfTriggerEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AfTrigger values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4e2c54ebb9dd200e458aea7632404f4aa4eafe63fd4aa2d2d2b373ed49f7bff8f"></a>AfTriggerStart&#160;</td><td class="fielddoc"><p>Start an AF scan. </p>
<p>Setting the control to AfTriggerStart is ignored if a scan is in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e2c54ebb9dd200e458aea7632404f4aaab71ac65071b07f1470c0e6ed5b28dda"></a>AfTriggerCancel&#160;</td><td class="fielddoc"><p>Cancel an AF scan. </p>
<p>This does not cause the lens to move anywhere else. Ignored if no scan is in progress. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5391455a1ad5a48225a771094c248e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5391455a1ad5a48225a771094c248e77">&#9670;&nbsp;</a></span>AnalogueGainModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a5391455a1ad5a48225a771094c248e77">libcamera::controls::AnalogueGainModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AnalogueGainMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5391455a1ad5a48225a771094c248e77ac284a93dd8086b5314c032b0d3b53e41"></a>AnalogueGainModeAuto&#160;</td><td class="fielddoc"><p>The analogue gain will be calculated automatically and set by the AEGC algorithm. </p>
<p>If AnalogueGain is set while this mode is active, it will be ignored, and it will also not be retained.</p>
<p>When transitioning from Manual to Auto mode, the AEGC should start its adjustments based on the last set manual AnalogueGain value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5391455a1ad5a48225a771094c248e77a4df9398e222fc283b2907b453d44c161"></a>AnalogueGainModeManual&#160;</td><td class="fielddoc"><p>The analogue gain will not be updated by the AEGC algorithm. </p>
<p>When transitioning from Auto to Manual mode, the last computed gain value is used until a new value is specified through the AnalogueGain control. If an AnalogueGain value is specified in the same request where the AnalogueGainMode is changed from Auto to Manual, the provided AnalogueGain is applied immediately. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7fcbbf6b3870d6edfd8cd00194df2ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcbbf6b3870d6edfd8cd00194df2ecb">&#9670;&nbsp;</a></span>AwbModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a7fcbbf6b3870d6edfd8cd00194df2ecb">libcamera::controls::AwbModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported AwbMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecba62fef2a2d68d34c0bebc4625283fb840"></a>AwbAuto&#160;</td><td class="fielddoc"><p>Search over the whole colour temperature range. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecbac16d54f93341c16a36f659fe8fbe0fcc"></a>AwbIncandescent&#160;</td><td class="fielddoc"><p>Incandescent AWB lamp mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecba10f02461a07df9c309c4ad112fb47312"></a>AwbTungsten&#160;</td><td class="fielddoc"><p>Tungsten AWB lamp mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecbac09f20250445c134efe0e75857e26660"></a>AwbFluorescent&#160;</td><td class="fielddoc"><p>Fluorescent AWB lamp mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecbaac5efee9f6698e60823dcc00ab5d8ca4"></a>AwbIndoor&#160;</td><td class="fielddoc"><p>Indoor AWB lighting mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecba0f7fd0bf3b7712f8cf5e6eb0e4cbab80"></a>AwbDaylight&#160;</td><td class="fielddoc"><p>Daylight AWB lighting mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecbaca45da6c684e2f2ecab739e5117c5df0"></a>AwbCloudy&#160;</td><td class="fielddoc"><p>Cloudy AWB lighting mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fcbbf6b3870d6edfd8cd00194df2ecba7966544b787350733159afcced744d1e"></a>AwbCustom&#160;</td><td class="fielddoc"><p>Custom AWB mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="a313d85600a65845f2f1b5a342804baf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313d85600a65845f2f1b5a342804baf2">&#9670;&nbsp;</a></span>ExposureTimeModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a313d85600a65845f2f1b5a342804baf2">libcamera::controls::ExposureTimeModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported ExposureTimeMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a313d85600a65845f2f1b5a342804baf2a058ab41be032e5537f04175a1ba88b54"></a>ExposureTimeModeAuto&#160;</td><td class="fielddoc"><p>The exposure time will be calculated automatically and set by the AE algorithm. </p>
<p>If ExposureTime is set while this mode is active, it will be ignored, and its value will not be retained.</p>
<p>When transitioning from Manual to Auto mode, the AEGC should start its adjustments based on the last set manual ExposureTime value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a313d85600a65845f2f1b5a342804baf2af814f59de1f8a81f87e0f0a0d1cdc19d"></a>ExposureTimeModeManual&#160;</td><td class="fielddoc"><p>The exposure time will not be updated by the AE algorithm. </p>
<p>When transitioning from Auto to Manual mode, the last computed exposure value is used until a new value is specified through the ExposureTime control. If an ExposureTime value is specified in the same request where the ExposureTimeMode is changed from Auto to Manual, the provided ExposureTime is applied immediately. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae0b385406bfae9e3f8f52632dee63c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b385406bfae9e3f8f52632dee63c63">&#9670;&nbsp;</a></span>HdrChannelEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#ae0b385406bfae9e3f8f52632dee63c63">libcamera::controls::HdrChannelEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported HdrChannel values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae0b385406bfae9e3f8f52632dee63c63aadbc7d6755e8fa99635acc4c1e92d57a"></a>HdrChannelNone&#160;</td><td class="fielddoc"><p>This image does not correspond to any of the captures used to create an HDR image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae0b385406bfae9e3f8f52632dee63c63a499b09f46bbbfd8b667ddbebfa34a2b1"></a>HdrChannelShort&#160;</td><td class="fielddoc"><p>This is a short exposure image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae0b385406bfae9e3f8f52632dee63c63a156cb979d82159e499b4e6b5c4a82d5e"></a>HdrChannelMedium&#160;</td><td class="fielddoc"><p>This is a medium exposure image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae0b385406bfae9e3f8f52632dee63c63ac48faee52c5df4b908434ac2d7d97763"></a>HdrChannelLong&#160;</td><td class="fielddoc"><p>This is a long exposure image. </p>
</td></tr>
</table>

</div>
</div>
<a id="a716de7c2d3556258c6787c02e41ee85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716de7c2d3556258c6787c02e41ee85e">&#9670;&nbsp;</a></span>HdrModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls.html#a716de7c2d3556258c6787c02e41ee85e">libcamera::controls::HdrModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported HdrMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a716de7c2d3556258c6787c02e41ee85ea1e04eae289d4d2c7222c4acc0a3d0624"></a>HdrModeOff&#160;</td><td class="fielddoc"><p>HDR is disabled. </p>
<p>Metadata for this frame will not include the HdrChannel control. </p>
</td></tr>
<tr><td class="fieldname"><a id="a716de7c2d3556258c6787c02e41ee85ea6a69a436a4e47b21d9c981e58aea6c69"></a>HdrModeMultiExposureUnmerged&#160;</td><td class="fielddoc"><p>Multiple exposures will be generated in an alternating fashion. </p>
<p>The multiple exposures will not be merged together and will be returned to the application as they are. Each image will be tagged with the correct HDR channel, indicating what kind of exposure it is. The tag should be the same as in the HdrModeMultiExposure case.</p>
<p>The expectation is that an application using this mode would merge the frames to create HDR images for itself if it requires them. </p>
</td></tr>
<tr><td class="fieldname"><a id="a716de7c2d3556258c6787c02e41ee85ea52e7a333bcb5d1fb0e305158d512d55c"></a>HdrModeMultiExposure&#160;</td><td class="fielddoc"><p>Multiple exposures will be generated and merged to create HDR images. </p>
<p>Each image will be tagged with the HDR channel (long, medium or short) that arrived and which caused this image to be output.</p>
<p>Systems that use two channels for HDR will return images tagged alternately as the short and long channel. Systems that use three channels for HDR will cycle through the short, medium and long channel before repeating. </p>
</td></tr>
<tr><td class="fieldname"><a id="a716de7c2d3556258c6787c02e41ee85ea9272871bd8d1866a9978fa4e425ad24c"></a>HdrModeSingleExposure&#160;</td><td class="fielddoc"><p>Multiple frames all at a single exposure will be used to create HDR images. </p>
<p>These images should be reported as all corresponding to the HDR short channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a716de7c2d3556258c6787c02e41ee85ea19c922530213a17afea7e2cedbcc2877"></a>HdrModeNight&#160;</td><td class="fielddoc"><p>Multiple frames will be combined to produce "night mode" images. </p>
<p>It is up to the implementation exactly which HDR channels it uses, and the images will all be tagged accordingly with the correct HDR channel information. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aff4b935254e0281dce87619a5ec64030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4b935254e0281dce87619a5ec64030">&#9670;&nbsp;</a></span>AeConstraintMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeConstraintMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a constraint mode for the AE algorithm to use. </p>
<p>The constraint modes determine how the measured scene brightness is adjusted to reach the desired target exposure. Constraint modes may be platform specific, and not all constraint modes may be supported. </p>

</div>
</div>
<a id="a7d4c815586c4b8054a73425bc25ae2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4c815586c4b8054a73425bc25ae2ab">&#9670;&nbsp;</a></span>AeEnable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the AEGC algorithm. When this control is set to true, both ExposureTimeMode and AnalogueGainMode are set to auto, and if this control is set to false then both are set to manual. </p>
<p>If ExposureTimeMode or AnalogueGainMode are also set in the same request as AeEnable, then the modes supplied by ExposureTimeMode or AnalogueGainMode will take precedence.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a3194f673027fc5367fc1244008c58949" title="Controls the source of the exposure time that is applied to the image sensor. ">ExposureTimeMode</a> <a class="el" href="namespacelibcamera_1_1controls.html#a86d5a2b6b98db922ef05fee98036c4e6" title="Controls the source of the analogue gain that is applied to the image sensor. ">AnalogueGainMode</a> </dd></dl>

</div>
</div>
<a id="a144b458b4e4261aa5f99c5fb5f4e904d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144b458b4e4261aa5f99c5fb5f4e904d">&#9670;&nbsp;</a></span>AeExposureMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeExposureMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify an exposure mode for the AE algorithm to use. </p>
<p>The exposure modes specify how the desired total exposure is divided between the exposure time and the sensor's analogue gain. They are platform specific, and not all exposure modes may be supported.</p>
<p>When one of AnalogueGainMode or ExposureTimeMode is set to Manual, the fixed values will override any choices made by AeExposureMode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a86d5a2b6b98db922ef05fee98036c4e6" title="Controls the source of the analogue gain that is applied to the image sensor. ">AnalogueGainMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a3194f673027fc5367fc1244008c58949" title="Controls the source of the exposure time that is applied to the image sensor. ">ExposureTimeMode</a> </dd></dl>

</div>
</div>
<a id="a5e70806b525b23bf9423889c2a56f932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e70806b525b23bf9423889c2a56f932">&#9670;&nbsp;</a></span>AeFlickerDetected</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeFlickerDetected</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flicker period detected in microseconds. </p>
<p>The value reported here indicates the currently detected flicker period, or zero if no flicker at all is detected.</p>
<p>When AeFlickerMode is set to FlickerAuto, there may be a period during which the value reported here remains zero. Once a non-zero value is reported, then this is the flicker period that has been detected and is now being cancelled.</p>
<p>In the case of 50Hz mains flicker, the value would be 10000 (corresponding to 100Hz), or 8333 (120Hz) for 60Hz mains flicker.</p>
<p>It is implementation dependent whether the system can continue to detect flicker of different periods when another frequency is already being cancelled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#af2283f6a757911a29b7b4bafd5b1eb21" title="Set the flicker avoidance mode for AGC/AEC. ">AeFlickerMode</a> </dd></dl>

</div>
</div>
<a id="af2283f6a757911a29b7b4bafd5b1eb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2283f6a757911a29b7b4bafd5b1eb21">&#9670;&nbsp;</a></span>AeFlickerMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeFlickerMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flicker avoidance mode for AGC/AEC. </p>
<p>The flicker mode determines whether, and how, the AGC/AEC algorithm attempts to hide flicker effects caused by the duty cycle of artificial lighting.</p>
<p>Although implementation dependent, many algorithms for "flicker
avoidance" work by restricting this exposure time to integer multiples of the cycle period, wherever possible.</p>
<p>Implementations may not support all of the flicker modes listed below.</p>
<p>By default the system will start in FlickerAuto mode if this is supported, otherwise the flicker mode will be set to FlickerOff. </p>

</div>
</div>
<a id="af0bb4529055bed66332a7fe28a81ca45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bb4529055bed66332a7fe28a81ca45">&#9670;&nbsp;</a></span>AeFlickerPeriod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeFlickerPeriod</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manual flicker period in microseconds. </p>
<p>This value sets the current flicker period to avoid. It is used when AeFlickerMode is set to FlickerManual.</p>
<p>To cancel 50Hz mains flicker, this should be set to 10000 (corresponding to 100Hz), or 8333 (120Hz) for 60Hz mains.</p>
<p>Setting the mode to FlickerManual when no AeFlickerPeriod has ever been set means that no flicker cancellation occurs (until the value of this control is updated).</p>
<p>Switching to modes other than FlickerManual has no effect on the value of the AeFlickerPeriod control.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#af2283f6a757911a29b7b4bafd5b1eb21" title="Set the flicker avoidance mode for AGC/AEC. ">AeFlickerMode</a> </dd></dl>

</div>
</div>
<a id="a94e6a00eada94491c46686ac16820a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e6a00eada94491c46686ac16820a35">&#9670;&nbsp;</a></span>AeMeteringMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeMeteringMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a metering mode for the AE algorithm to use. </p>
<p>The metering modes determine which parts of the image are used to determine the scene brightness. Metering modes may be platform specific and not all metering modes may be supported. </p>

</div>
</div>
<a id="ac77dcb68a923dc60e28c475374d76221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77dcb68a923dc60e28c475374d76221">&#9670;&nbsp;</a></span>AeState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AeState</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the AEGC algorithm state. </p>
<p>The AEGC algorithm computes the exposure time and the analogue gain to be applied to the image sensor.</p>
<p>The AEGC algorithm behaviour is controlled by the ExposureTimeMode and AnalogueGainMode controls, which allow applications to decide how the exposure time and gain are computed, in Auto or Manual mode, independently from one another.</p>
<p>The AeState control reports the AEGC algorithm state through a single value and describes it as a single computation block which computes both the exposure time and the analogue gain values.</p>
<p>When both the exposure time and analogue gain values are configured to be in Manual mode, the AEGC algorithm is quiescent and does not actively compute any value and the AeState control will report AeStateIdle.</p>
<p>When at least the exposure time or analogue gain are configured to be computed by the AEGC algorithm, the AeState control will report if the algorithm has converged to stable values for all of the controls set to be computed in Auto mode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a86d5a2b6b98db922ef05fee98036c4e6" title="Controls the source of the analogue gain that is applied to the image sensor. ">AnalogueGainMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a3194f673027fc5367fc1244008c58949" title="Controls the source of the exposure time that is applied to the image sensor. ">ExposureTimeMode</a> </dd></dl>

</div>
</div>
<a id="a4822d64036849aca4e912c50a0e608aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4822d64036849aca4e912c50a0e608aa">&#9670;&nbsp;</a></span>AfMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The mode of the AF (autofocus) algorithm. </p>
<p>An implementation may choose not to implement all the modes. </p>

</div>
</div>
<a id="a3f3b19553e399472896cf33c5f59095b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3b19553e399472896cf33c5f59095b">&#9670;&nbsp;</a></span>AfPause</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfPause</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause lens movements when in continuous autofocus mode. </p>
<p>This control has no effect except when in continuous autofocus mode (AfModeContinuous). It can be used to pause any lens movements while (for example) images are captured. The algorithm remains inactive until it is instructed to resume. </p>

</div>
</div>
<a id="a73f3467ef96f2044ef9e2065847ea2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f3467ef96f2044ef9e2065847ea2b5">&#9670;&nbsp;</a></span>AfPauseState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfPauseState</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report whether the autofocus is currently running, paused or pausing. </p>
<p>This control is only applicable in continuous (AfModeContinuous) mode, and reports whether the algorithm is currently running, paused or pausing (that is, will pause as soon as any in-progress scan completes).</p>
<p>Any change to AfMode will cause AfPauseStateRunning to be reported. </p>

</div>
</div>
<a id="a3aa4c185f9f3e22b2c4bae54d787ec9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa4c185f9f3e22b2c4bae54d787ec9a">&#9670;&nbsp;</a></span>AfRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfRange</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The range of focus distances that is scanned. </p>
<p>An implementation may choose not to implement all the options here. </p>

</div>
</div>
<a id="a1e57fbabf7c8844be7ee309aade7c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e57fbabf7c8844be7ee309aade7c775">&#9670;&nbsp;</a></span>AfSpeed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfSpeed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the AF is to move the lens as quickly as possible or more steadily. </p>
<p>For example, during video recording it may be desirable not to move the lens too abruptly, but when in a preview mode (waiting for a still capture) it may be helpful to move the lens as quickly as is reasonably possible. </p>

</div>
</div>
<a id="af5e92d34fe6f91772c475cea4f4f648c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e92d34fe6f91772c475cea4f4f648c">&#9670;&nbsp;</a></span>AfState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfState</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current state of the AF algorithm. </p>
<p>This control reports the current state of the AF algorithm in conjunction with the reported AfMode value and (in continuous AF mode) the AfPauseState value. The possible state changes are described below, though we note the following state transitions that occur when the AfMode is changed.</p>
<p>If the AfMode is set to AfModeManual, then the AfState will always report AfStateIdle (even if the lens is subsequently moved). Changing to the AfModeManual state does not initiate any lens movement.</p>
<p>If the AfMode is set to AfModeAuto then the AfState will report AfStateIdle. However, if AfModeAuto and AfTriggerStart are sent together then AfState will omit AfStateIdle and move straight to AfStateScanning (and start a scan).</p>
<p>If the AfMode is set to AfModeContinuous then the AfState will initially report AfStateScanning. </p>

</div>
</div>
<a id="ad78de9c118dda5b8fe763c1e4f643791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78de9c118dda5b8fe763c1e4f643791">&#9670;&nbsp;</a></span>AfTrigger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an autofocus scan. </p>
<p>This control starts an autofocus scan when AfMode is set to AfModeAuto, and is ignored if AfMode is set to AfModeManual or AfModeContinuous. It can also be used to terminate a scan early. </p>

</div>
</div>
<a id="aeece9e5e8fd738c5446efbdb06f93aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeece9e5e8fd738c5446efbdb06f93aac">&#9670;&nbsp;</a></span>AfWindows</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AfWindows</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The focus windows used by the AF algorithm when AfMetering is set to AfMeteringWindows. </p>
<p>The units used are pixels within the rectangle returned by the ScalerCropMaximum property.</p>
<p>In order to be activated, a rectangle must be programmed with non-zero width and height. Internally, these rectangles are intersected with the ScalerCropMaximum rectangle. If the window becomes empty after this operation, then the window is ignored. If all the windows end up being ignored, then the behaviour is platform dependent.</p>
<p>On platforms that support the ScalerCrop control (for implementing digital zoom, for example), no automatic recalculation or adjustment of AF windows is performed internally if the ScalerCrop is changed. If any window lies outside the output image after the scaler crop has been applied, it is up to the application to recalculate them.</p>
<p>The details of how the windows are used are platform dependent. We note that when there is more than one AF window, a typical implementation might find the optimal focus position for each one and finally select the window where the focal distance for the objects shown in that part of the image are closest to the camera. </p>

</div>
</div>
<a id="ab34ebeaa9cbfb3f3fc6996b089ca52b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34ebeaa9cbfb3f3fc6996b089ca52b0">&#9670;&nbsp;</a></span>AnalogueGain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AnalogueGain</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analogue gain value applied in the sensor device. </p>
<p>The value of the control specifies the gain multiplier applied to all colour channels. This value cannot be lower than 1.0.</p>
<p>This control will only take effect if AnalogueGainMode is Manual. If this control is set when AnalogueGainMode is Auto, the value will be ignored and will not be retained.</p>
<p>When reported in metadata, this control indicates what analogue gain was used for the current request, regardless of AnalogueGainMode. AnalogueGainMode will indicate the source of the analogue gain value, whether it came from the AEGC algorithm or not.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a4e1ca45653b62cd969d4d67a741076eb" title="Exposure time for the frame applied in the sensor device. ">ExposureTime</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a86d5a2b6b98db922ef05fee98036c4e6" title="Controls the source of the analogue gain that is applied to the image sensor. ">AnalogueGainMode</a> </dd></dl>

</div>
</div>
<a id="a86d5a2b6b98db922ef05fee98036c4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d5a2b6b98db922ef05fee98036c4e6">&#9670;&nbsp;</a></span>AnalogueGainMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AnalogueGainMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the source of the analogue gain that is applied to the image sensor. </p>
<p>When set to Auto, the AEGC algorithm computes the analogue gain and configures the image sensor accordingly. When set to Manual, the value of the AnalogueGain control is used.</p>
<p>When transitioning from Auto to Manual mode and no AnalogueGain control is provided by the application, the last value computed by the AEGC algorithm when the mode was Auto will be used. If the AnalogueGainMode was never set to Auto (either because the camera started in Manual mode, or Auto is not supported by the camera), the camera should use a best-effort default value.</p>
<p>If AnalogueGainModeManual is supported, the AnalogueGain control must also be supported.</p>
<p>For cameras where we have control over the ISP, both ExposureTimeMode and AnalogueGainMode are expected to support manual mode, and both controls (as well as ExposureTimeMode and AnalogueGain) are expected to be present. If the camera also has an AEGC implementation, both ExposureTimeMode and AnalogueGainMode shall support both manual and auto mode. If auto mode is available, it shall be the default mode. These rules do not apply to black box cameras such as UVC cameras, where the available gain and exposure modes are completely dependent on what the hardware exposes.</p>
<p>The same procedure described for performing flickerless transitions in the ExposureTimeMode control documentation can be applied to analogue gain.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a3194f673027fc5367fc1244008c58949" title="Controls the source of the exposure time that is applied to the image sensor. ">ExposureTimeMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#ab34ebeaa9cbfb3f3fc6996b089ca52b0" title="Analogue gain value applied in the sensor device. ">AnalogueGain</a> </dd></dl>

</div>
</div>
<a id="a3a05d11b6f22d7ed3798da7bb29a3936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a05d11b6f22d7ed3798da7bb29a3936">&#9670;&nbsp;</a></span>AwbEnable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AwbEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the AWB. </p>
<p>When AWB is enabled, the algorithm estimates the colour temperature of the scene and computes colour gains and the colour correction matrix automatically. The computed colour temperature, gains and correction matrix are reported in metadata. The corresponding controls are ignored if set in a request.</p>
<p>When AWB is disabled, the colour temperature, gains and correction matrix are not updated automatically and can be set manually in requests.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#ae41d67783e62f20de02a621417d222aa" title="The 3x3 matrix that converts camera RGB to sRGB within the imaging pipeline. ">ColourCorrectionMatrix</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#ace9f01b925044ae563a6e08e930ebff7" title="Pair of gain values for the Red and Blue colour channels, in that order. ">ColourGains</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a8754d2609a3a04ce5ec5880d5d4e8e5d" title="ColourTemperature of the frame, in kelvin. ">ColourTemperature</a> </dd></dl>

</div>
</div>
<a id="aef8709c3405367852efae5b93af96fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8709c3405367852efae5b93af96fb6">&#9670;&nbsp;</a></span>AwbLocked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AwbLocked</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the lock status of a running AWB algorithm. </p>
<p>If the AWB algorithm is locked the value shall be set to true, if it's converging it shall be set to false. If the AWB algorithm is not running the control shall not be present in the metadata control list.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a3a05d11b6f22d7ed3798da7bb29a3936" title="Enable or disable the AWB. ">AwbEnable</a> </dd></dl>

</div>
</div>
<a id="a1f8a8390defcb16e20d247df9e892eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8a8390defcb16e20d247df9e892eee">&#9670;&nbsp;</a></span>AwbMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::AwbMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the range of illuminants to use for the AWB algorithm. </p>
<p>The modes supported are platform specific, and not all modes may be supported. </p>

</div>
</div>
<a id="a0d2d1f1f31581c9d80a433230753a0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2d1f1f31581c9d80a433230753a0de">&#9670;&nbsp;</a></span>Brightness</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::Brightness</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a fixed brightness parameter. </p>
<p>Positive values (up to 1.0) produce brighter images; negative values (up to -1.0) produce darker images and 0.0 leaves pixels unchanged. </p>

</div>
</div>
<a id="ae41d67783e62f20de02a621417d222aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41d67783e62f20de02a621417d222aa">&#9670;&nbsp;</a></span>ColourCorrectionMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::ColourCorrectionMatrix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The 3x3 matrix that converts camera RGB to sRGB within the imaging pipeline. </p>
<p>This should describe the matrix that is used after pixels have been white-balanced, but before any gamma transformation. The 3x3 matrix is stored in conventional reading order in an array of 9 floating point values.</p>
<p>ColourCorrectionMatrix can only be applied in a <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request. ">Request</a> when the AWB is disabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a3a05d11b6f22d7ed3798da7bb29a3936" title="Enable or disable the AWB. ">AwbEnable</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a8754d2609a3a04ce5ec5880d5d4e8e5d" title="ColourTemperature of the frame, in kelvin. ">ColourTemperature</a> </dd></dl>

</div>
</div>
<a id="ace9f01b925044ae563a6e08e930ebff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9f01b925044ae563a6e08e930ebff7">&#9670;&nbsp;</a></span>ColourGains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::ColourGains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of gain values for the Red and Blue colour channels, in that order. </p>
<p>ColourGains can only be applied in a <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request. ">Request</a> when the AWB is disabled. If ColourGains is set in a request but ColourTemperature is not, the implementation shall calculate and set the ColourTemperature based on the ColourGains.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a3a05d11b6f22d7ed3798da7bb29a3936" title="Enable or disable the AWB. ">AwbEnable</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a8754d2609a3a04ce5ec5880d5d4e8e5d" title="ColourTemperature of the frame, in kelvin. ">ColourTemperature</a> </dd></dl>

</div>
</div>
<a id="a8754d2609a3a04ce5ec5880d5d4e8e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8754d2609a3a04ce5ec5880d5d4e8e5d">&#9670;&nbsp;</a></span>ColourTemperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::ColourTemperature</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ColourTemperature of the frame, in kelvin. </p>
<p>ColourTemperature can only be applied in a <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request. ">Request</a> when the AWB is disabled.</p>
<p>If ColourTemperature is set in a request but ColourGains is not, the implementation shall calculate and set the ColourGains based on the given ColourTemperature. If ColourTemperature is set (either directly, or indirectly by setting ColourGains) but ColourCorrectionMatrix is not, the ColourCorrectionMatrix is updated based on the ColourTemperature.</p>
<p>The ColourTemperature used to process the frame is reported in metadata.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a3a05d11b6f22d7ed3798da7bb29a3936" title="Enable or disable the AWB. ">AwbEnable</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#ae41d67783e62f20de02a621417d222aa" title="The 3x3 matrix that converts camera RGB to sRGB within the imaging pipeline. ">ColourCorrectionMatrix</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#ace9f01b925044ae563a6e08e930ebff7" title="Pair of gain values for the Red and Blue colour channels, in that order. ">ColourGains</a> </dd></dl>

</div>
</div>
<a id="a76f39d8c7048f1cea3af63bd2839d6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f39d8c7048f1cea3af63bd2839d6b4">&#9670;&nbsp;</a></span>Contrast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::Contrast</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a fixed contrast parameter. </p>
<p>Normal contrast is given by the value 1.0; larger values produce images with more contrast. </p>

</div>
</div>
<a id="a886fdba02620052f01c89a6686d17537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886fdba02620052f01c89a6686d17537">&#9670;&nbsp;</a></span>controls</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelibcamera.html#a7d3fda0fdcda064b681b36fff326cdb7">ControlIdMap</a> libcamera::controls::controls</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all supported libcamera controls. </p>
<p>Unless otherwise stated, all controls are bi-directional, i.e. they can be set through <a class="el" href="classlibcamera_1_1Request.html#ae9327d49f60d15c34c90bb3d2f4cba10" title="Retrieve the request&#39;s ControlList. ">Request::controls()</a> and returned out through <a class="el" href="classlibcamera_1_1Request.html#ac620539cc50a28bd9ff9f8f697eb86c3" title="Retrieve the request&#39;s metadata. ">Request::metadata()</a>. </p>

</div>
</div>
<a id="a82c8beb7cf9d9f048c5007a68922a5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c8beb7cf9d9f048c5007a68922a5b1">&#9670;&nbsp;</a></span>DigitalGain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::DigitalGain</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Digital gain value applied during the processing steps applied to the image as captured from the sensor. </p>
<p>The global digital gain factor is applied to all the colour channels of the RAW image. Different pipeline models are free to specify how the global gain factor applies to each separate channel.</p>
<p>If an imaging pipeline applies digital gain in distinct processing steps, this value indicates their total sum. Pipelines are free to decide how to adjust each processing step to respect the received gain factor and shall report their total value in the request metadata. </p>

</div>
</div>
<a id="a4e1ca45653b62cd969d4d67a741076eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1ca45653b62cd969d4d67a741076eb">&#9670;&nbsp;</a></span>ExposureTime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::ExposureTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exposure time for the frame applied in the sensor device. </p>
<p>This value is specified in microseconds.</p>
<p>This control will only take effect if ExposureTimeMode is Manual. If this control is set when ExposureTimeMode is Auto, the value will be ignored and will not be retained.</p>
<p>When reported in metadata, this control indicates what exposure time was used for the current frame, regardless of ExposureTimeMode. ExposureTimeMode will indicate the source of the exposure time value, whether it came from the AE algorithm or not.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#ab34ebeaa9cbfb3f3fc6996b089ca52b0" title="Analogue gain value applied in the sensor device. ">AnalogueGain</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a3194f673027fc5367fc1244008c58949" title="Controls the source of the exposure time that is applied to the image sensor. ">ExposureTimeMode</a> </dd></dl>

</div>
</div>
<a id="a3194f673027fc5367fc1244008c58949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3194f673027fc5367fc1244008c58949">&#9670;&nbsp;</a></span>ExposureTimeMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::ExposureTimeMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the source of the exposure time that is applied to the image sensor. </p>
<p>When set to Auto, the AE algorithm computes the exposure time and configures the image sensor accordingly. When set to Manual, the value of the ExposureTime control is used.</p>
<p>When transitioning from Auto to Manual mode and no ExposureTime control is provided by the application, the last value computed by the AE algorithm when the mode was Auto will be used. If the ExposureTimeMode was never set to Auto (either because the camera started in Manual mode, or Auto is not supported by the camera), the camera should use a best-effort default value.</p>
<p>If ExposureTimeModeManual is supported, the ExposureTime control must also be supported.</p>
<p>Cameras that support manual control of the sensor shall support manual mode for both ExposureTimeMode and AnalogueGainMode, and shall expose the ExposureTime and AnalogueGain controls. If the camera also has an AEGC implementation, both ExposureTimeMode and AnalogueGainMode shall support both manual and auto mode. If auto mode is available, it shall be the default mode. These rules do not apply to black box cameras such as UVC cameras, where the available gain and exposure modes are completely dependent on what the device exposes.</p>
<dl class="section user"><dt>Flickerless exposure mode transitions</dt><dd></dd></dl>
<p>Applications that wish to transition from ExposureTimeModeAuto to direct control of the exposure time without causing extra flicker can do so by selecting an ExposureTime value as close as possible to the last value computed by the auto exposure algorithm in order to avoid any visible flickering.</p>
<p>To select the correct value to use as ExposureTime value, applications should accommodate the natural delay in applying controls caused by the capture pipeline frame depth.</p>
<p>When switching to manual exposure mode, applications should not immediately specify an ExposureTime value in the same request where ExposureTimeMode is set to Manual. They should instead wait for the first <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request. ">Request</a> where ExposureTimeMode is reported as ExposureTimeModeManual in the <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request. ">Request</a> metadata, and use the reported ExposureTime to populate the control value in the next <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request. ">Request</a> to be queued to the <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device. ">Camera</a>.</p>
<p>The implementation of the auto-exposure algorithm should equally try to minimize flickering and when transitioning from manual exposure mode to auto exposure use the last value provided by the application as starting point.</p>
<ol type="1">
<li>Start with ExposureTimeMode set to Auto</li>
<li>Set ExposureTimeMode to Manual</li>
<li>Wait for the first completed request that has ExposureTimeMode set to Manual</li>
<li>Copy the value reported in ExposureTime into a new request, and submit it</li>
<li>Proceed to run manual exposure time as desired</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a4e1ca45653b62cd969d4d67a741076eb" title="Exposure time for the frame applied in the sensor device. ">ExposureTime</a> </dd></dl>

</div>
</div>
<a id="a7b8ba16db6502e4106b646019600c98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8ba16db6502e4106b646019600c98d">&#9670;&nbsp;</a></span>ExposureValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::ExposureValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify an Exposure Value (EV) parameter. </p>
<p>The EV parameter will only be applied if the AE algorithm is currently enabled, that is, at least one of AnalogueGainMode and ExposureTimeMode are in Auto mode.</p>
<p>By convention EV adjusts the exposure as log2. For example EV = [-2, -1, -0.5, 0, 0.5, 1, 2] results in an exposure adjustment of [1/4x, 1/2x, 1/sqrt(2)x, 1x, sqrt(2)x, 2x, 4x].</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a86d5a2b6b98db922ef05fee98036c4e6" title="Controls the source of the analogue gain that is applied to the image sensor. ">AnalogueGainMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a3194f673027fc5367fc1244008c58949" title="Controls the source of the exposure time that is applied to the image sensor. ">ExposureTimeMode</a> </dd></dl>

</div>
</div>
<a id="a3c5f034588ba57aaeb4d0d79ce0735e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5f034588ba57aaeb4d0d79ce0735e2">&#9670;&nbsp;</a></span>FocusFoM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::FocusFoM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a Figure of Merit (FoM) to indicate how in-focus the frame is. </p>
<p>A larger FocusFoM value indicates a more in-focus frame. This singular value may be based on a combination of statistics gathered from multiple focus regions within an image. The number of focus regions and method of combination is platform dependent. In this respect, it is not necessarily aimed at providing a way to implement a focus algorithm by the application, rather an indication of how in-focus a frame is. </p>

</div>
</div>
<a id="a37d99a76c7249c143beecd70917469be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d99a76c7249c143beecd70917469be">&#9670;&nbsp;</a></span>FrameDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::FrameDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The instantaneous frame duration from start of frame exposure to start of next exposure, expressed in microseconds. </p>
<p>This control is meant to be returned in metadata. </p>

</div>
</div>
<a id="a4f3236ff99d40a3a44fcd1ad77c4458f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3236ff99d40a3a44fcd1ad77c4458f">&#9670;&nbsp;</a></span>FrameDurationLimits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::FrameDurationLimits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum and maximum (in that order) frame duration, expressed in microseconds. </p>
<p>When provided by applications, the control specifies the sensor frame duration interval the pipeline has to use. This limits the largest exposure time the sensor can use. For example, if a maximum frame duration of 33ms is requested (corresponding to 30 frames per second), the sensor will not be able to raise the exposure time above 33ms. A fixed frame duration is achieved by setting the minimum and maximum values to be the same. Setting both values to 0 reverts to using the camera defaults.</p>
<p>The maximum frame duration provides the absolute limit to the exposure time computed by the AE algorithm and it overrides any exposure mode setting specified with <a class="el" href="namespacelibcamera_1_1controls.html#a144b458b4e4261aa5f99c5fb5f4e904d" title="Specify an exposure mode for the AE algorithm to use. ">controls::AeExposureMode</a>. Similarly, when a manual exposure time is set through <a class="el" href="namespacelibcamera_1_1controls.html#a4e1ca45653b62cd969d4d67a741076eb" title="Exposure time for the frame applied in the sensor device. ">controls::ExposureTime</a>, it also gets clipped to the limits set by this control. When reported in metadata, the control expresses the minimum and maximum frame durations used after being clipped to the sensor provided frame duration limits.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a144b458b4e4261aa5f99c5fb5f4e904d" title="Specify an exposure mode for the AE algorithm to use. ">AeExposureMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls.html#a4e1ca45653b62cd969d4d67a741076eb" title="Exposure time for the frame applied in the sensor device. ">ExposureTime</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>Define how to calculate the capture frame rate by defining controls to report additional delays introduced by the capture pipeline or post-processing stages (ie JPEG conversion, frame scaling).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>Provide an explicit definition of default control values, for this and all other controls. </dd></dl>

</div>
</div>
<a id="aa4db106ea27d988584ca1f730207602f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4db106ea27d988584ca1f730207602f">&#9670;&nbsp;</a></span>FrameWallClock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::FrameWallClock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This timestamp corresponds to the same moment in time as the SensorTimestamp, but is represented as a wall clock time as measured by the CLOCK_REALTIME clock. Like SensorTimestamp, the timestamp value is expressed in nanoseconds. </p>
<p>Being a wall clock measurement, it can be used to synchronise timing across different devices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a0198b0e9a054328e84a4024b19742ec9" title="The time when the first row of the image sensor active array is exposed. ">SensorTimestamp</a></dd></dl>
<p>The FrameWallClock control can only be returned in metadata. </p>

</div>
</div>
<a id="a75bc162c4f3818ea673b541ef7a69118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bc162c4f3818ea673b541ef7a69118">&#9670;&nbsp;</a></span>Gamma</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::Gamma</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a fixed gamma value. </p>
<p>The default gamma value must be 2.2 which closely mimics sRGB gamma. Note that this is camera gamma, so it is applied as 1.0/gamma. </p>

</div>
</div>
<a id="a9834a875f8dd3928fb9ea76eaa3780a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9834a875f8dd3928fb9ea76eaa3780a1">&#9670;&nbsp;</a></span>HdrChannel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::HdrChannel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HDR channel used to capture the frame. </p>
<p>This value is reported back to the application so that it can discover whether this capture corresponds to the short or long exposure image (or any other image used by the HDR procedure). An application can monitor the HDR channel to discover when the differently exposed images have arrived.</p>
<p>This metadata is only available when an HDR mode has been enabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a6db8fe54958db67aaef37c0d7e65444d" title="Set the mode to be used for High Dynamic Range (HDR) imaging. ">HdrMode</a> </dd></dl>

</div>
</div>
<a id="a6db8fe54958db67aaef37c0d7e65444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db8fe54958db67aaef37c0d7e65444d">&#9670;&nbsp;</a></span>HdrMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::HdrMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the mode to be used for High Dynamic Range (HDR) imaging. </p>
<p>HDR techniques typically include multiple exposure, image fusion and tone mapping techniques to improve the dynamic range of the resulting images.</p>
<p>When using an HDR mode, images are captured with different sets of AGC settings called HDR channels. Channels indicate in particular the type of exposure (short, medium or long) used to capture the raw image, before fusion. Each HDR image is tagged with the corresponding channel using the HdrChannel control.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a9834a875f8dd3928fb9ea76eaa3780a1" title="The HDR channel used to capture the frame. ">HdrChannel</a> </dd></dl>

</div>
</div>
<a id="acfb623408035e51db904a0f3928a863e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb623408035e51db904a0f3928a863e">&#9670;&nbsp;</a></span>LensPosition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::LensPosition</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set and report the focus lens position. </p>
<p>This control instructs the lens to move to a particular position and also reports back the position of the lens for each frame.</p>
<p>The LensPosition control is ignored unless the AfMode is set to AfModeManual, though the value is reported back unconditionally in all modes.</p>
<p>This value, which is generally a non-integer, is the reciprocal of the focal distance in metres, also known as dioptres. That is, to set a focal distance D, the lens position LP is given by</p>
<p><img class="formulaInl" alt="$LP = \frac{1\mathrm{m}}{D}$" src="form_0.png"/></p>
<p>For example:</p>
<ul>
<li>0 moves the lens to infinity.</li>
<li>0.5 moves the lens to focus on objects 2m away.</li>
<li>2 moves the lens to focus on objects 50cm away.</li>
<li>And larger values will focus the lens closer.</li>
</ul>
<p>The default value of the control should indicate a good general position for the lens, often corresponding to the hyperfocal distance (the closest position for which objects at infinity are still acceptably sharp). The minimum will often be zero (meaning infinity), and the maximum value defines the closest focus position.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Define a property to report the Hyperfocal distance of calibrated lenses. </dd></dl>

</div>
</div>
<a id="a930ae3cc7e47afd69580506ec6eed67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930ae3cc7e47afd69580506ec6eed67b">&#9670;&nbsp;</a></span>Lux</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::Lux</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report an estimate of the current illuminance level in lux. </p>
<p>The Lux control can only be returned in metadata. </p>

</div>
</div>
<a id="a928cbed69ee40ea268c9efcd07557521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928cbed69ee40ea268c9efcd07557521">&#9670;&nbsp;</a></span>Saturation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::Saturation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a fixed saturation parameter. </p>
<p>Normal saturation is given by the value 1.0; larger values produce more saturated colours; 0.0 produces a greyscale image. </p>

</div>
</div>
<a id="a854f9e84af827f57ada03fcc12090c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854f9e84af827f57ada03fcc12090c56">&#9670;&nbsp;</a></span>ScalerCrop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::ScalerCrop</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the image portion that will be scaled to form the whole of the final output image. </p>
<p>The (x,y) location of this rectangle is relative to the PixelArrayActiveAreas that is being used. The units remain native sensor pixels, even if the sensor is being used in a binning or skipping mode.</p>
<p>This control is only present when the pipeline supports scaling. Its maximum valid value is given by the <a class="el" href="namespacelibcamera_1_1properties.html#aa5962f3f157e9e0bc67171a8db8eeb6d" title="The maximum valid rectangle for the controls::ScalerCrop control. This reflects the minimum mandatory...">properties::ScalerCropMaximum</a> property, and the two can be used to implement digital zoom. </p>

</div>
</div>
<a id="a2e998ced522d1c5c2de3857c86a34cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e998ced522d1c5c2de3857c86a34cbe">&#9670;&nbsp;</a></span>SensorBlackLevels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::SensorBlackLevels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the sensor black levels used for processing a frame. </p>
<p>The values are in the order R, Gr, Gb, B. They are returned as numbers out of a 16-bit pixel range (as if pixels ranged from 0 to 65535). The SensorBlackLevels control can only be returned in metadata. </p>

</div>
</div>
<a id="a90b04df1f95d44b02807be3ddbd9a028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b04df1f95d44b02807be3ddbd9a028">&#9670;&nbsp;</a></span>SensorTemperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::SensorTemperature</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temperature measure from the camera sensor in Celsius. </p>
<p>This value is typically obtained by a thermal sensor present on-die or in the camera module. The range of reported temperatures is device dependent.</p>
<p>The SensorTemperature control will only be returned in metadata if a thermal sensor is present. </p>

</div>
</div>
<a id="a0198b0e9a054328e84a4024b19742ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0198b0e9a054328e84a4024b19742ec9">&#9670;&nbsp;</a></span>SensorTimestamp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::SensorTimestamp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The time when the first row of the image sensor active array is exposed. </p>
<p>The timestamp, expressed in nanoseconds, represents a monotonically increasing counter since the system boot time, as defined by the Linux-specific CLOCK_BOOTTIME clock id.</p>
<p>The SensorTimestamp control can only be returned in metadata.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Define how the sensor timestamp has to be used in the reprocessing use case. </dd></dl>

</div>
</div>
<a id="aeb754676a763e2d339474b335dfdbd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb754676a763e2d339474b335dfdbd8e">&#9670;&nbsp;</a></span>Sharpness</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::Sharpness</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intensity of the sharpening applied to the image. </p>
<p>A value of 0.0 means no sharpening. The minimum value means minimal sharpening, and shall be 0.0 unless the camera can't disable sharpening completely. The default value shall give a "reasonable" level of sharpening, suitable for most use cases. The maximum value may apply extremely high levels of sharpening, higher than anyone could reasonably want. Negative values are not allowed. Note also that sharpening is not applied to raw streams. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
